
Function calls:
  Possibly still module:function but then allow .blah(x).blah(x) etc. that is
  the equivalent of efn/ifn small-arrow syntax(?)

Implement a lot of the features with macro language (astify etc.)

Sequence syntax
Struct

Dashes in atom names (and therefore function-names)?
Questionmarks in atoms and therefore function-names

Whitespace deliniated lists
Dangling commas in lists

"Built-in" regular expressions (compiles re at compile-time)
String interpolation  ("blah ~s" ~ MyStr) or ("blah ~b ~s" ~ [123, MyStr])

Ternary expressions
Shortcuts for type conversion functions (make polymorphic)
Shortcut guard expressions
  - allow '?' at end of function defs
  - is_list()  -> l?() etc.
  - some_fun|Blah:atom, etc

Clean and easily nested record syntax

== Basic libraries ==
Way better string & binary string library
Wrap around things like ~p and other pretty-print / basic string IO for the
    shell.

== Higher level libraries ==
Redis? http-bridge?

== Tools ==
Drop-in erlc replacement
Drop-in erl replacement ?
Super better shell


== Don't know yet... ==
Take any spec/type or combo and turn it into a (possibly deeply nested) guard
  sequence?
Override operators (?)
Syntax for function parameter defaults?
More common use of packages?
Special reassign variable syntax (like Var! or something) that is essentially
  going to turn into a parsing hack, but allows redefinition when it really
  makes sense...?







Expression ->
  Term -> Data (Number, Atom, List, Tuple, ...)
  Variables -> Hold a term value (after bound)
  Pattern -> like Term but with unbound variables
  Match -> Assignment with pattern matching.  Pattern = Term
  Function Calls ->
  Fun Expressions ->
  If
  Case
  Send
  Receive
  Term Comparisons
  Arithmetic
  Boolean & shortcircuit
  List Operations
  Binary Operations
  Catch and Throw
  Try
  Parenthesized Expression
  Block Expression (similar to clause body)
  List comprehension
  Binary comprehension
  Guard sequence


 <  >
 {  }
 [  ]
 (  )
 |  |
<[  ]>
<<  >>


