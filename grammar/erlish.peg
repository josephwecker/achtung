%------------ Grammar --------------------------------------------------------
grammar       <- (_s form)* _s                              `[p2(F)||F<-?P1]`;
form          <- attribute / function                                       ~;

%------------ Attributes -----------------------------------------------------
attribute     <- module                                        `{attr, Node}`;
module        <- "@module" sp atom                                      `?P3`;

%------------ Functions ------------------------------------------------------
function      <- atom expression              `{function, ?P1, listify(?P2)}`;

%------------ Terms / Atomic Literals ----------------------------------------
term          <- atom / number / string                                     ~;

atom          <- simple_atom / complex_atom                          `?S2LIT`;
simple_atom   <- [a-z] [a-z0-9_@?]*                            `[$',Node,$']`;
complex_atom  <- "'" not_apos* "'"                                          ~;
not_apos      <- !"'" ("\\" . / !"\\" .)                                `?P2`;

number        <- [+-]? (float / integer)                            `?FIXNUM`;
integer       <- base_int / normal_int / character                          ~;
normal_int    <- [0-9] [0-9_]*                                              ~;
base_int      <- base_prefix [A-Za-z0-9_]+                                  ~;
base_prefix   <- "0" [xX] / "0" [oO] / "0" [bB] / ([1-9] [0-9]* [rR]) `?BASE`;
character     <- "$" (char_escapes / .)                                     ~;
char_escapes  <- "\\^" [a-zA-Z] / "\\" o (o o?)? / "\\x{" h+ "}" /
                 "\\x" h h / "\\" .                                         ~;
o             <- [0-7]                                                      ~;
h             <- [0-9a-fA-F]                                                ~;
float         <- normal_int "." normal_int+ ([eE] [-+]? normal_int)?        ~;

string        <- simple_string / long_string                         `?S2LIT`;
simple_string <- '"' not_quot* '"'                                          ~;
not_quot      <- !'"' ("\\" . / !"\\" .)                                `?P2`;
long_string   <- "'''" not_triple_ap* "'''"                             `?P2`;
%long_string   <- "'''" not_triple_ap* "'''"                    `fixlstr(?P2)`;
not_triple_ap <- !"'''" ("\\" "'''" / "\\" . / !"\\" .)                 `?P2`;
%------------ Expressions ----------------------------------------------------
expression    <- _s (block / expr_with_end)                             `?P2`;
block         <- block_beg expression* expr? block_end     `append_(?P2,?P3)`;
expr_with_end <- expr eos                                               `?P1`;
expr          <- term                                                       ~;

%------------ Whitespace, Comments, Delimiters -------------------------------
block_beg     <- _s ("{" _s indent / indent _s "{" / "{" / indent)       `?X`;
block_end     <- _s ("}" _s dedent / dedent _s "}" / "}" / dedent)       `?X`;
indent        <- "\x06"                                                  `?X`;
dedent        <- "\x15"                                                  `?X`;
eos           <- _sp (";" / newline / !.)                                `?X`;
_s            <- ws?                                                     `?X`;
ws            <- (space / newline)+                                      `?X`;
newline       <- comment? "\n" / "\r\n" / "\r"                           `?X`;
_sp           <- sp?                                                     `?X`;
sp            <- space+                                                  `?X`;
space         <- [ \t] / ml_comment                                      `?X`;
comment       <- "#" (!newline .)* &newline                              `?X`;
ml_inner      <- ml_comment / (!"#|" !"|#" .)+                           `?X`;
ml_comment    <- "#|" ml_inner* "|#"                                     `?X`;

%------------ Shortcut / helper functions ------------------------------------
`
-define(L,       line(Index)).     % Current line #
-define(X,       []).              % Consume but ignore

% Node unpacking
-define(P1,      p1(Node)).
-define(P2,      p2(Node)).
-define(P3,      p3(Node)).
-define(GET(Key),all(Key, Node)).
-define(FLAT,    flat(Node)).
-define(RM(C),   rm_char(C, flat(Node),[])).

% Used for literals
-define(BASE,    base(Node)).
-define(FIXNUM,  fix_num(Node, Index)).
-define(S2L(X),  literal(flat(X),Index)). % Basically let Erlang turn it into a literal
-define(S2LIT,   ?S2L(Node)).

% For node unpacking
flat(L)       -> lists:flatten(L).
%all(Key, L)   -> proplists:get_all_values(Key, flat(L)).
p1([R|_])     -> R.
p2([_,R|_])   -> R.
p3([_,_,R|_]) -> R.

% Append V onto L only if V has something
append_(L,V)  -> case V of [] -> L; _ -> lists:append(L,[V]) end.

% Make sure it's a list
listify(V) when is_list(V) -> V;
listify(V)    -> [V].

literal(X, Index)  ->
  % TODO: pass along any errors here as appropriate
  {ok, Lit, _EndLoc} = erl_scan:string(X, line(Index)),
  case Lit of
    [Single] -> Single;
    M when is_list(M) -> M
      % much more serious- an actual list- which I haven't implemented yet.
      %[T || <-M, 
      %Multiple
  end.

rm_char(C, L)            -> rm_char(C, L, []).
rm_char(_, [], Acc)      -> lists:reverse(Acc);
rm_char(C, [C | T], Acc) -> rm_char(C, T, Acc);
rm_char(C, [H | T], Acc) -> rm_char(C, T, [H | Acc]).

%fixlstr(LStr) ->

% Utilities used for numbers
base(["0",$X])->"16#";
base(["0",$x])->"16#";
base(["0",$O])->"8#";
base(["0",$o])->"8#";
base(["0",$B])->"2#";
base(["0",$b])->"2#";
base([D1, DN, $R]) -> [flat([D1,DN,"#"])];
base([D1, DN, $r]) -> [flat([D1,DN,"#"])].

fix_num(Num, Line) -> fix_num2(rm_char($_,rm_char($+,flat(Num))), Line).
fix_num2([$- | Num], Line) ->
  {T, L, V} = literal(Num, Line),
  {T, L, -V};
fix_num2(Num, Line) -> literal(Num, Line).

% vim: set noai filetype=erlang textwidth=100:
`
