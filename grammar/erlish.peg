%------------ Grammar --------------------------------------------------------
grammar       <- (_s form)* _s                              `[p2(F)||F<-?P1]`;
form          <- attribute / function                                       ~;

%------------ Attributes -----------------------------------------------------
attribute     <- module                                        `{attr, Node}`;
module        <- "@module" sp atom                                      `?P3`;

%------------ Functions ------------------------------------------------------
function      <- atom expression              `{function, ?P1, listify(?P2)}`;

%------------ Terms / Atomic Literals ----------------------------------------
term          <- atom / number                                              ~;
atom          <- simple_atom / complex_atom                          `?S2LIT`;
simple_atom   <- [a-z] [a-z0-9_@]*                                          ~;
complex_atom  <- "'" not_apos* "'"                                          ~;
not_apos      <- !"'" ("\\" . / !"\\" .)                                `?P2`;
%number        <- [+-]? (float / integer / character)
number        <- integer                                                    ~;
integer       <- base_int / normal_int / character               `?S2L(?RM_)`;
normal_int    <- [0-9] [0-9_]*                                              ~;
base_int      <- base_prefix [A-Za-z0-9_]+                                  ~;
base_prefix   <- "0x" / "0o" / "0b" / ([1-9] [0-9]* "r")              `?BASE`;
character     <- "$" ("\\" . / .)                                           ~;

%------------ Expressions ----------------------------------------------------
expression    <- _s (block / expr_with_end)                             `?P2`;
block         <- block_beg expression* expr? block_end     `append_(?P2,?P3)`;
expr_with_end <- expr eos                                               `?P1`;
expr          <- term                                                       ~;

%------------ Whitespace, Comments, Delimiters -------------------------------
block_beg     <- _s ("{" _s indent / indent _s "{" / "{" / indent)       `?X`;
block_end     <- _s ("}" _s dedent / dedent _s "}" / "}" / dedent)       `?X`;
indent        <- "\x06"                                                  `?X`;
dedent        <- "\x15"                                                  `?X`;
eos           <- _sp (";" / newline / !.)                                `?X`;
_s            <- ws?                                                     `?X`;
ws            <- (space / newline)+                                      `?X`;
newline       <- comment? "\n" / "\r\n" / "\r"                           `?X`;
_sp           <- sp?                                                     `?X`;
sp            <- space+                                                  `?X`;
space         <- [ \t] / ml_comment                                      `?X`;
comment       <- "#" (!newline .)* &newline                              `?X`;
ml_inner      <- ml_comment / (!"#|" !"|#" .)+                           `?X`;
ml_comment    <- "#|" ml_inner* "|#"                                     `?X`;

%------------ Shortcut / helper functions ------------------------------------
`
-define(L,       line(Index)).     % Current line #
-define(X,       []).              % Consume but ignore

% Node unpacking
-define(P1,      p1(Node)).
-define(P2,      p2(Node)).
-define(P3,      p3(Node)).
-define(GET(Key),all(Key, Node)).

% Used for numbers
-define(RM_,     rm_underscores(flat(Node),[])).
-define(BASE,    base(Node)).

% Basically let Erlang turn it into a literal
-define(S2L(X),  literal(flat(X), ?L)).
-define(S2LIT,   ?S2L(Node)).

% For node unpacking
flat(L)       -> lists:flatten(L).
all(Key, L)   -> proplists:get_all_values(Key, flat(L)).
p1([R|_])     -> R.
p2([_,R|_])   -> R.
p3([_,_,R|_]) -> R.

% Append V onto L only if V has something
append_(L,V)  -> case V of [] -> L; _ -> lists:append(L,[V]) end.

% Make sure it's a list
listify(V) when is_list(V) -> V;
listify(V)    -> [V].

literal(X,L)  -> {ok,[{T,_,V}],_}=erl_scan:string(X), {T,L,V}.

% Utilities used for numbers
rm_underscores([],Acc)     -> lists:reverse(Acc);
rm_underscores([$_|T],Acc) -> rm_underscores(T,Acc);
rm_underscores([H|T],Acc)  -> rm_underscores(T,[H|Acc]).

base("0x")->"16#";
base("0o")->"8#";
base("0b")->"2#";
base([D1, DN, "r"]) -> [flat([D1,DN,"#"])].

% vim: set noai filetype=erlang textwidth=100:
`
