%------------ Grammar --------------------------------------------------------
grammar       <- (_s form)* _s                       `?post_process(?i(2,1))`;
form          <- attribute / function                                       ~;

%------------ Attributes -----------------------------------------------------
attribute     <- "@" _s (attrs / wild_attr)                             `?p3`;
attrs         <- module / package / params / compile                        ~;
module        <- "module" sp module_name openlist?         `?c_mod2(?p3,?p4)`;
module_name   <- chained_atom                                      `?unlist1`;
%export        <- "export" openlist                           `?c_export(?p2)`;
%inline        <- "inline" openlist                           `?c_inline(?p2)`;
%behavior      <- ("behaviour" / "behavior") _sp atom          `?c_behav(?p3)`;
compile       <- "compile" openlist                                 `?c_attr`;
package       <- "package" _sp chained_atom                `?c_attr(?p1,?p3)`;
params        <- "parameters" openlist                              `?c_attr`;
wild_attr     <- atom openlist?                                     `?c_attr`;

% TODO: YOU ARE HERE (kind of):
%  - go get basic module parsing working
%  - get export working
%  - get inline working
%  - move onto something else.

%------------ Functions ------------------------------------------------------
% This is the top-level function definition
%function      <- atom clauses                          `?c_function(?p1,?p2)`;
function      <- atom clauses                        `?c_tlfunction(?p1,?p2)`;
% TODO: ability for all of these to be variables (if supported by erlang)
funsig        <- chained_atom "/" [0-9]+                   `?c_fsig(?p1,?p3)`;

%------------ Clauses --------------------------------------------------------
clauses       <- clauseblock / clause                              `?listify`;
clause        <- _s "|"? pattern? guardseq? _s "->" clause_expr     `?clause`;
%clause_expr   <- _s expr_with_end? exp_block?              `?flat([?p2,?p3])`;
clause_expr   <- _s expressions?
clauseblock   <- sblock clause+ eblock                                  `?p2`;

pattern       <- (_s term)+                                            `?ip2`; % TMP
guardseq      <- _s "||" (_s guard_expr)*                         `?ip2(?p3)`; % TMP
guard_expr    <- (_s term)+                                            `?ip2`; % TMP

%------------ Expressions ----------------------------------------------------
% This may look confusing because of the explicit blocks (exp_block) vs.
% normal blocks (block).  Normal blocks don't have "begin ... end"- but if a
% block suddenly starts in the middle of a bunch of expressions, it does get
% a begin...end (that's the exp_block).

%expressions   <- expression+                                          `?flat`;
%expression    <- _s (block / expr_with_end)                             `?p2`;
%inner_exp     <- _s (exp_block / expr_with_end)                         `?p2`;
%exp_block     <- sblock inner_exp* expr? eblock     `?c_block(?app(?p2,?p3))`;
%block         <- sblock inner_exp* expr? eblock               `?app(?p2,?p3)`;

expressions   <- ( expr_inline expr_block ) / expr_inline / expr_block  `?flat`;
%expr_inline   <- ( _sp expr _sp nl ) / ( _sp expr eoinline)+        `?i(2,1)`;
expr_block    <- sblock expr_seq eblock                                 `?p2`;
expr_seq      <- expression+                                                ~;
expression    <- expr eos                                               `?p1`;
expr          <- term                                                       ~;

%------------ Terms / Atomic Literals ----------------------------------------
term          <- string / funsig / atom / number / tuple / list / variable  ~;

atom          <- simple_atom / complex_atom                           `?scan`;
simple_atom   <- [a-z] [a-z0-9_@?]*                            `[$',Node,$']`;
complex_atom  <- "'" not_apos* "'"                                          ~;
not_apos      <- !"'" ("\\" . / !"\\" .)                                `?p2`;

chained_atom  <- atom ("." atom)* _sp !"("         `?fix_ch_a([?p1|?i(2,2)])`;

number        <- [+-]? (float / integer)                            `?fixnum`;
integer       <- base_int / normal_int / character                          ~;
normal_int    <- [0-9] [0-9_]*                                              ~;
base_int      <- base_prefix [A-Za-z0-9_]+                                  ~;
base_prefix   <- "0" [xX] / "0" [oO] / "0" [bB] / ([1-9] [0-9]* [rR]) `?base`;
character     <- "$" (char_escapes / .)                                     ~;
char_escapes  <- "\\^" [a-zA-Z] / "\\" o (o o?)? / "\\x{" h+ "}" /
                 "\\x" h h / "\\" .                                         ~;
o             <- [0-7]                                                      ~;
h             <- [0-9a-fA-F]                                                ~;
float         <- normal_int "." normal_int+ ([eE] [-+]? normal_int)?        ~;

string        <- (_s string_part)+                              `?cats(?ip2)`;
string_part   <- simple_string / long_string                          `?scan`;
simple_string <- '"' not_quot* '"'                                          ~;
not_quot      <- !'"' ("\\" . / !"\\" .)                                `?p2`;
long_string   <- "'''" not_triple_ap* "'''"                   `?fixlstr(?p2)`;
not_triple_ap <- !"'''" ("\\" "'''" / "\\" . / !"\\" .)                 `?p2`;

%------------ Tuples & Lists -------------------------------------------------
% You'd think you could factor out a lot of the redundency here, but it
% currently confuses neotoma, which fails to try subsequent patterns
% sometimes.  This works, for now, even if it is an eye sore.
tuple         <- _s (empty_t / comma_t / space_t)             `?c_tuple(?p2)`;
empty_t       <- "(" _s ")"                                              `[]`;
comma_t       <- "(" _s term (_s "," _s term)* _s ")"         `[?p3|?i(4,4)]`;
space_t       <- "(" _s term ("\\"? s term)* _s ")"           `[?p3|?i(3,4)]`;

list          <- _s (empty_l / comma_l / space_l)              `?c_list(?p2)`;
empty_l       <- "[" _s t? "]"                                           `[]`;
comma_l       <- "[" _s term (_s "," _s term)* _s t? "]"`{[?p3|?i(4,4)],?p6}`;
space_l       <- "[" _s term ("\\"? s term)* _s t? "]"  `{[?p3|?i(3,4)],?p6}`;
t             <- "|" _s term _s                                         `?p3`;

% openlist acts kind of like a tuple, but doesn't have begin/end delimiters
% other than the end of the line or block
openlist      <- _s (empty_ol / comma_ol / space_ol)                    `?p2`;
empty_ol      <- eos                                                     `[]`;
comma_ol      <- comma_ol_inl comma_ol_blk?                        `?p1++?p2`;
comma_ol_inl  <- term (_sp "," _sp term)* ","? eos            `[?p1|?i(4,2)]`;
comma_ol_blk  <- sblock term? (_s "," _s term)* eblock        `[?p2|?i(4,3)]`;
space_ol      <- space_ol_inl space_ol_blk?                        `?p1++?p2`;
space_ol_inl  <- (_sp term)* eos                                    `?i(2,1)`;
space_ol_blk  <- sblock (_s term)* eblock                           `?i(2,2)`;

%------------ Variables ------------------------------------------------------
variable      <- [A-Z_] [A-Za-z0-9?_]*                               `?c_var`;

%------------ Whitespace, Comments, Delimiters -------------------------------
% TODO: Clarify/shore-up:
%   * "super"-indents
%   * escaped newlines
%   * openlists (esp. in combination with the two above)
%
sblock        <- _s ("{" _s indent / indent _s "{" / "{" / indent)       `?X`;
eblock        <- _s ("}" _s dedent / dedent _s "}" / "}" / dedent)       `?X`;
eos           <- _sp (";" / nl / !.)                                     `?X`; % End of a statement
eoinline      <- _sp (";" / !.)                                          `?X`; % End of inline statement
_s            <- s?                                                      `?X`; % Optional whitespace
s             <- (space / nl)+                                           `?X`; % At least one whitespace/newline
nl            <- comment? newline                                        `?X`; % End of a line
_sp           <- sp?                                                     `?X`; % Optional spacing (no newline)
sp            <- space+                                                  `?X`; % At least one space (not newline)

% These build up the whitespace rules above and should (I think) never be used
% except in those rules just above.
newline       <- "\n" / "\r\n" / "\r"                                    `?X`;
space         <- [ \t] / ml_comment                                      `?X`;
comment       <- "#" (!newline .)* &newline                              `?X`;
ml_inner      <- ml_comment / (!"#|" !"|#" .)+                           `?X`;
ml_comment    <- "#|" ml_inner* "|#"                                     `?X`;
indent        <- "\x06"                                                  `?X`;
dedent        <- "\x15"                                                  `?X`;

%------------ Shortcuts & transformations ------------------------------------
`
% Common macros
-include("../include/ungbar.hrl").

% Macros that are specific to this grammar

% Functions
% Break into simple structures to be recombined later - so that arity and even
% interleaving don't matter
-define(c_tlfunction(Name,Clauses),
  [{tl_function, ?pos, Name, length(element(3,C)),C} || C <- Clauses]).
  
-define(clause, ?clause(?N)).
-define(clause(N),
  begin
      [_, _, Pattern, Guard, _, _, Body] = N,
      % TODO: turn type declarations into parts of the guard
      ?c_clause(Pattern,Guard,?listify(Body))
  end).

% Numbers
-define(base,   base(?N)).
-define(fixnum, fix_num(?N, ?I)).

base(["0",$X])->"16#";
base(["0",$x])->"16#";
base(["0",$O])->"8#";
base(["0",$o])->"8#";
base(["0",$B])->"2#";
base(["0",$b])->"2#";
base([D1, DN, $R]) -> [?flat([D1,DN,"#"])];
base([D1, DN, $r]) -> [?flat([D1,DN,"#"])].

% Flatten, remove underscores and positive signs, scan, and then apply
% negative sign if necessary.
fix_num(Node,Index)      ->fix_num2(rm_char($_,rm_char($+,?flat)), Index).
fix_num2([$-|Node],Index)->{T,L,V}=?scan, {T,L,-V};
fix_num2(Node,Index)     ->?scan.


% Strings
% Not really necessary usually (epp does this as well) - but I think it's safer
% here anyway: concatenate strings that are in a sequence.
-define(cats, ?cats(?N)).
-define(cats(Ss), erl_parse:abstract(?flat(lists:append([erl_parse:normalise(S)||S<-Ss])))).

-define(fixlstr, ?fixlstr(?N)).
-define(fixlstr(N), ["\"", rm_char($","\\\"",?flat(N)), "\""]).

% Misc
-define(fix_ch_a(Atoms), [?v_atom(A)||A<-Atoms]).


rm_char(C,L)        ->rm_char(C,[],L,[]).
rm_char(C,R,L)      ->rm_char(C,R,L,[]).
rm_char(_,_,[],A)   ->?flat(?rev(A));
rm_char(C,R,[C|T],A)->rm_char(C,R,T,[R|A]);
rm_char(C,R,[H|T],A)->rm_char(C,R,T,[H|A]).

% Separates a normal complex erlang module declaration into three attributes,
% which then get checked and recombined later in post-processing.
-define(c_mod2(Name, Ps),  % Separates into several attributes when necessary
  begin
      A = case Ps of
        []->[];
        _->[{attribute,?pos,parameters,[?v_atom(P)||P<-Ps]}]
      end,
      case Name of
        [M]->[{attribute,?pos,module,M}|A];
        L when is_list(L) ->
          [M|Pkg] = ?rev(L),
          [{attribute,?pos,module,M},{attribute,?pos,package,?rev(Pkg)}|A]
      end
  end).

% Higher level semantics
% Returns {ok, ErlangForms, LastPos} or ...?
% TODO:
%   - Gather and possibly reorganize function definitions
%

-define(post_process,    post_process(?N,?pos)).
-define(post_process(N), post_process(N,?pos)).
post_process(AST, Pos) ->
  {Attrs, Funs} = lists:partition(fun(V)->element(1,V) == attribute end, lists:flatten(AST)),
  {Funs2, Avail, Exports, Inlines} = grouped_funs(Funs),
  {ok, Attrs ++ Funs2, Pos}.


grouped_funs(Funs) -> grouped_funs(Funs, [], [], [], []).
grouped_funs([],FunsAcc,AvailAcc,ExportAcc,InlineAcc)->{?rev(FunsAcc),AvailAcc,ExportAcc,InlineAcc};
grouped_funs([{_,FirstPos,AN,AA,_} | _] = Remaining, FunsAcc, AvailAcc, ExportAcc, InlineAcc) ->
  {FunGroup, Remaining2} = lists:partition(
    fun({_,_,BN,BA,_})-> {?v_atom(AN),AA}=={?v_atom(BN),BA} end,
    Remaining),
  Clauses = [C || {_,_,_,_,C} <- FunGroup],
  Fun = {function, FirstPos, ?v_atom(AN), AA, Clauses},
  grouped_funs(Remaining2, [Fun | FunsAcc], [{?v_atom(AN),AA}|AvailAcc],[],[]).


% vim: set noai filetype=erlang textwidth=100:
`
