%------------ Grammar --------------------------------------------------------
grammar       <- (_s form)* _s                        `{ok, ?ip2(?p1), ?pos}`;
form          <- attribute / function                                       ~;

%------------ Attributes -----------------------------------------------------
attribute     <- module                                        `{attr, Node}`;
module        <- "@module" sp atom                                      `?p3`;

%------------ Functions ------------------------------------------------------
function      <- atom clauses                           `?c_function(?p1,?p2)`;

%------------ Clauses --------------------------------------------------------
clauses       <- clauseblock / clause                              `?listify`;
clause        <- _s "|"? pattern? guardseq? _s "->" expressions     `?clause`;
clauseblock   <- sblock clause+ eblock                                  `?p2`;

pattern       <- (_s term)+                                            `?ip2`; % TMP
guardseq      <- _s "||" (_s guard_expr)*                         `?ip2(?p3)`; % TMP
guard_expr    <- (_s term)+                                            `?ip2`; % TMP

%------------ Expressions ----------------------------------------------------
% This may look confusing because of the explicit blocks (exp_block) vs.
% normal blocks (block).  Normal blocks don't have "begin ... end"- but if a
% block suddenly starts in the middle of a bunch of expressions, it does get
% a begin...end (that's the exp_block).
expressions   <- expression+                                          `?flat`;
expression    <- _s (block / expr_with_end)                             `?p2`;
inner_exp     <- _s (exp_block / expr_with_end)                         `?p2`;
exp_block     <- sblock inner_exp* expr? eblock     `?c_block(?app(?p2,?p3))`;
block         <- sblock inner_exp* expr? eblock               `?app(?p2,?p3)`;
expr_with_end <- expr eos                                               `?p1`;
expr          <- term                                                       ~;

%------------ Terms / Atomic Literals ----------------------------------------
term          <- atom / number / string                                     ~;

atom          <- simple_atom / complex_atom                          `?S2LIT`;
simple_atom   <- [a-z] [a-z0-9_@?]*                            `[$',Node,$']`;
complex_atom  <- "'" not_apos* "'"                                          ~;
not_apos      <- !"'" ("\\" . / !"\\" .)                                `?p2`;

number        <- [+-]? (float / integer)                            `?FIXNUM`;
integer       <- base_int / normal_int / character                          ~;
normal_int    <- [0-9] [0-9_]*                                              ~;
base_int      <- base_prefix [A-Za-z0-9_]+                                  ~;
base_prefix   <- "0" [xX] / "0" [oO] / "0" [bB] / ([1-9] [0-9]* [rR]) `?BASE`;
character     <- "$" (char_escapes / .)                                     ~;
char_escapes  <- "\\^" [a-zA-Z] / "\\" o (o o?)? / "\\x{" h+ "}" /
                 "\\x" h h / "\\" .                                         ~;
o             <- [0-7]                                                      ~;
h             <- [0-9a-fA-F]                                                ~;
float         <- normal_int "." normal_int+ ([eE] [-+]? normal_int)?        ~;

string        <- simple_string / long_string                         `?S2LIT`;
simple_string <- '"' not_quot* '"'                                          ~;
not_quot      <- !'"' ("\\" . / !"\\" .)                                `?p2`;
long_string   <- "'''" not_triple_ap* "'''"                             `?p2`;
%long_string   <- "'''" not_triple_ap* "'''"                    `fixlstr(?p2)`;
not_triple_ap <- !"'''" ("\\" "'''" / "\\" . / !"\\" .)                 `?p2`;

%------------ Whitespace, Comments, Delimiters -------------------------------
sblock        <- _s ("{" _s indent / indent _s "{" / "{" / indent)       `?X`;
eblock        <- _s ("}" _s dedent / dedent _s "}" / "}" / dedent)       `?X`;
indent        <- "\x06"                                                  `?X`;
dedent        <- "\x15"                                                  `?X`;
eos           <- _sp (";" / newline / !.)                                `?X`;
_s            <- ws?                                                     `?X`;
ws            <- (space / newline)+                                      `?X`;
newline       <- comment? "\n" / "\r\n" / "\r"                           `?X`;
_sp           <- sp?                                                     `?X`;
sp            <- space+                                                  `?X`;
space         <- [ \t] / ml_comment                                      `?X`;
comment       <- "#" (!newline .)* &newline                              `?X`;
ml_inner      <- ml_comment / (!"#|" !"|#" .)+                           `?X`;
ml_comment    <- "#|" ml_inner* "|#"                                     `?X`;

%------------ Shortcuts & transformations ------------------------------------
`
-include("../include/ungbar.hrl").

% Functions
-define(clause, ?clause(?N)).
-define(clause(N),
  begin
      [_, _, Pattern, Guard, _, _, Body] = N,
      % TODO: turn type declarations into parts of the guard
      ?c_clause(Pattern,Guard,?listify(Body))
  end).

% Numbers
base(["0",$X])->"16#";
base(["0",$x])->"16#";
base(["0",$O])->"8#";
base(["0",$o])->"8#";
base(["0",$B])->"2#";
base(["0",$b])->"2#";
base([D1, DN, $R]) -> [?flat([D1,DN,"#"])];
base([D1, DN, $r]) -> [?flat([D1,DN,"#"])].

fix_num(Num, Line) -> fix_num2(rm_char($_,rm_char($+,?flat(Num))), Line).
fix_num2([$- | Num], Line) ->
  {T, L, V} = literal(Num, Line),
  {T, L, -V};
fix_num2(Num, Line) -> literal(Num, Line).

% vim: set noai filetype=erlang textwidth=100:
`
