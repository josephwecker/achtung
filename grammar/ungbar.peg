%------------ Grammar --------------------------------------------------------
grammar       <- (_s form)* _s                       `?post_process(?i(2,1))`;
form          <- attribute / function                                       ~;

%------------ Attributes -----------------------------------------------------
attribute     <- "@" _s (attrs / wild_attr)                             `?p3`;
attrs         <- module / package / params / compile / export               ~;
module        <- "module" sp module_name openlist?         `?uc_mod(?p3,?p4)`;
module_name   <- chained_atom                                      `?unlist1`;
export        <- "export" openlist                          `?uc_export(?p2)`;
compile       <- "compile" openlist                                 `?c_attr`;
package       <- "package" _sp chained_atom                `?c_attr(?p1,?p3)`;
params        <- "parameters" openlist                              `?c_attr`;
wild_attr     <- atom openlist?                                     `?c_attr`;

%------------ Functions ------------------------------------------------------
% This is the top-level function definition
function      <- atom clauses                         `?uc_function(?p1,?p2)`;
% TODO: ability for all of these to be variables (if supported by erlang)
funsig        <- chained_atom "/" [0-9]+                   `?c_fsig(?p1,?p3)`;

%------------ Clauses --------------------------------------------------------
clauses       <- clauseblock / clause                              `?listify`;
clause        <- _s "|"? pattern_seq? guardseq? _s "->" expr_sblk `?uc_clause`;
clauseblock   <- sblock clause+ eblock                                  `?p2`;

guardseq      <- _s "||" (_s guard_expr)*                         `?ip2(?p3)`; % TMP
guard_expr    <- (_s literal)+                                         `?ip2`; % TMP

pattern       <- literal / p_tuple / p_list / p_variable                    ~;
pattern_seq   <- space_ps / comma_ps                                        ~;
comma_ps      <- _s pattern (_s "," _s pattern)*              `[?p2|?i(4,3)]`;
space_ps      <- _s pattern (s pattern)+                      `[?p2|?i(2,3)]`;

%------------ Expressions ----------------------------------------------------
expr_sblk     <- expr_seq expr_blk / expr_blk / expr_seq              `?flat`;
expr_blk      <- sblock expr_seq+ eblock                                `?p2`;
expr_seq      <- expr_sp (";" expr_sp)* ";"? (nl _s / &"}")   `[?p1|?i(2,2)]`;
expr_sp       <- _sp expr _sp                                           `?p2`;
expr          <- funsig / literal / e_tuple / e_list / e_variable           ~;

%------------ Terms / Atomic Literals ----------------------------------------
literal       <- string / atom / number  ~;

atom          <- simple_atom / complex_atom                           `?scan`;
simple_atom   <- [a-z] [a-z0-9_@?]*                            `[$',Node,$']`;
complex_atom  <- "'" not_apos* "'"                                          ~;
not_apos      <- !"'" ("\\" . / !"\\" .)                                `?p2`;

chained_atom  <- atom ("." atom)* _sp !"("         `?fix_ch_a([?p1|?i(2,2)])`;

number        <- [+-]? (float / integer)                            `?fixnum`;
integer       <- base_int / normal_int / character                          ~;
normal_int    <- [0-9] [0-9_]*                                              ~;
base_int      <- base_prefix [A-Za-z0-9_]+                                  ~;
base_prefix   <- "0" [xX] / "0" [oO] / "0" [bB] / ([1-9] [0-9]* [rR]) `?base`;
character     <- "$" (char_escapes / .)                                     ~;
char_escapes  <- "\\^" [a-zA-Z] / "\\" o (o o?)? / "\\x{" h+ "}" /
                 "\\x" h h / "\\" .                                         ~;
o             <- [0-7]                                                      ~;
h             <- [0-9a-fA-F]                                                ~;
float         <- normal_int "." normal_int+ ([eE] [-+]? normal_int)?        ~;

string        <- (_s string_part)+                              `?cats(?ip2)`;
string_part   <- simple_string / long_string                          `?scan`;
simple_string <- '"' not_quot* '"'                                          ~;
not_quot      <- !'"' ("\\" . / !"\\" .)                                `?p2`;
long_string   <- "'''" not_triple_ap* "'''"                   `?fixlstr(?p2)`;
not_triple_ap <- !"'''" ("\\" "'''" / "\\" . / !"\\" .)                 `?p2`;

%------------ Tuples & Lists -------------------------------------------------
% You'd think you could factor out a lot of the redundency here, but it
% currently confuses neotoma, which fails to try subsequent patterns
% sometimes.  This works, for now, even if it is an eye sore.
e_tuple       <- _s (empty_t / e_comma_t / e_space_t)         `?c_tuple(?p2)`;
e_comma_t     <- "(" _s expr (_s "," _s expr)* _s ")"         `[?p3|?i(4,4)]`;
e_space_t     <- "(" _s expr ("\\"? s expr)* _s ")"           `[?p3|?i(3,4)]`;

e_list        <- _s (empty_l / e_comma_l / e_space_l)          `?c_list(?p2)`;
e_comma_l     <- "[" _s expr (_s "," _s expr)* _s e_t? "]" `{[?p3|?i(4,4)],?p6}`;
e_space_l     <- "[" _s expr ("\\"? s expr)* _s e_t? "]"   `{[?p3|?i(3,4)],?p6}`;
e_t           <- "|" _s expr _s                                         `?p3`;

p_tuple       <- _s (empty_t / p_comma_t / p_space_t)         `?c_tuple(?p2)`;
p_comma_t     <- "(" _s pattern (_s "," _s pattern)* _s ")"   `[?p3|?i(4,4)]`;
p_space_t     <- "(" _s pattern ("\\"? s pattern)* _s ")"     `[?p3|?i(3,4)]`;

p_list        <- _s (empty_l / p_comma_l / p_space_l)          `?c_list(?p2)`;
p_comma_l     <- "[" _s pattern (_s "," _s pattern)* _s p_t? "]" `{[?p3|?i(4,4)],?p6}`;
p_space_l     <- "[" _s pattern ("\\"? s pattern)* _s p_t? "]"   `{[?p3|?i(3,4)],?p6}`;
p_t           <- "|" _s pattern _s                                      `?p3`;

empty_l       <- "[" _s "]"                                              `[]`;
empty_t       <- "(" _s ")"                                              `[]`;

% openlist acts kind of like a tuple, but doesn't have begin/end delimiters
% other than the end of the line or block
openlist      <- _s (empty_ol / comma_ol / space_ol)                    `?p2`;
empty_ol      <- eos                                                     `[]`;
comma_ol      <- comma_ol_inl comma_ol_blk?                        `?p1++?p2`;
comma_ol_inl  <- expr (_sp "," _sp expr)* ","? eos            `[?p1|?i(4,2)]`;
comma_ol_blk  <- sblock expr? (_s "," _s expr)* eblock        `[?p2|?i(4,3)]`;
space_ol      <- space_ol_inl space_ol_blk?                        `?p1++?p2`;
space_ol_inl  <- (_sp expr)* eos                                    `?i(2,1)`;
space_ol_blk  <- sblock (_s expr)* eblock                           `?i(2,2)`;

%------------ Variables ------------------------------------------------------
p_variable    <- [A-Z_] [A-Za-z0-9?_]*                               `?c_var`;
e_variable    <- [A-Z] [A-Za-z0-9?_]*                                `?c_var`;

%------------ Whitespace, Comments, Delimiters -------------------------------
sblock        <- _s ("{" _s indent / indent _s "{" / "{" / indent) _s    `?X`;
eblock        <- _s ("}" _s dedent / dedent _s "}" / "}" / dedent) _s    `?X`;
eos           <- _sp (";" / nl / !.)                                     `?X`; % End of a statement
_s            <- s?                                                      `?X`; % Optional whitespace
s             <- (space / nl)+                                           `?X`; % At least one whitespace/newline
nl            <- comment? newline                                        `?X`; % End of a line
_sp           <- sp?                                                     `?X`; % Optional spacing (no newline)
sp            <- space+                                                  `?X`; % At least one space (not newline)

% These build up the whitespace rules above and should (I think) never be used
% except in those rules just above.
newline       <- "\n" / "\r\n" / "\r"                                    `?X`;
space         <- [ \t] / ml_comment                                      `?X`;
comment       <- "#" (!newline .)* &newline                              `?X`;
ml_inner      <- ml_comment / (!"#|" !"|#" .)+                           `?X`;
ml_comment    <- "#|" ml_inner* "|#"                                     `?X`;
indent        <- "\x06"                                                  `?X`;
dedent        <- "\x15"                                                  `?X`;

%------------ Shortcuts & transformations ------------------------------------
`
% Common macros
-include("../include/ungbar.hrl").

% Usage examples for error messages
-define(EXPORT_EXAMPLE,
  "  # Exports all versions of my_function\n"
  "@export my_function\n"
  "  # Only my_function with arity 2 and all versions of another_function\n"
  "@export my_function/2 another_function").

% Macros that are specific to this grammar - when they override something
% usually done in ungbar.hrl they say uc_... instead of c_...

% Numbers
-define(base,   base(?N)).
-define(fixnum, fix_num(?N, ?I)).

base(["0",$X])->"16#";
base(["0",$x])->"16#";
base(["0",$O])->"8#";
base(["0",$o])->"8#";
base(["0",$B])->"2#";
base(["0",$b])->"2#";
base([D1, DN, $R]) -> [?flat([D1,DN,"#"])];
base([D1, DN, $r]) -> [?flat([D1,DN,"#"])].

% Flatten, remove underscores and positive signs, scan, and then apply
% negative sign if necessary.
fix_num(Node,Index)      ->fix_num2(rm_char($_,rm_char($+,?flat)), Index).
fix_num2([$-|Node],Index)->{T,L,V}=?scan, {T,L,-V};
fix_num2(Node,Index)     ->?scan.

% Strings
% Not really necessary usually (epp does this as well) - but I think it's safer
% here anyway: concatenate strings that are in a sequence.
-define(cats, ?cats(?N)).
-define(cats(Ss), erl_parse:abstract(?flat(lists:append([erl_parse:normalise(S)||S<-Ss])))).
-define(fixlstr, ?fixlstr(?N)).
-define(fixlstr(N), ["\"", rm_char($","\\\"",?flat(N)), "\""]).
% Misc
-define(fix_ch_a(Atoms), [?v_atom(A)||A<-Atoms]). % For atom chains

% Remove (or replace) a character
rm_char(C,L)        ->rm_char(C,[],L,[]).
rm_char(C,R,L)      ->rm_char(C,R,L,[]).
rm_char(_,_,[],A)   ->?flat(?rev(A));
rm_char(C,R,[C|T],A)->rm_char(C,R,T,[R|A]);
rm_char(C,R,[H|T],A)->rm_char(C,R,T,[H|A]).

% Functions
% Break into simple structures to be recombined later - so that arity and
% even interleaving don't matter
-define(uc_function(Name,Clauses),
  [{uc_function, ?pos, Name, length(element(3,C)),C} || C <- Clauses]).
  
-define(uc_clause, ?uc_clause(?N)).
-define(uc_clause(N),
  begin
      [_, _, Pattern, Guard, _, _, Body] = N,
      ?c_clause(Pattern,Guard,?listify(Body))
  end).

-define(uc_export(L), {attribute, ?pos, export, L}).

% Separates a normal complex erlang module declaration into three attributes,
% which then get checked and recombined later in post-processing.
-define(uc_mod(Name, Ps),  % Separates into several attributes when necessary
  begin
      A = case Ps of
        []->[];
        _->[{attribute,?pos,parameters,[?v_atom(P)||P<-Ps]}]
      end,
      case Name of
        [M]->[{attribute,?pos,module,M}|A];
        L when is_list(L) ->
          [M|Pkg] = ?rev(L),
          [{attribute,?pos,module,M},{attribute,?pos,package,?rev(Pkg)}|A]
      end
  end).


%------------ Higher Level Symantics -----------------------------------------

-define(post_process,    post_process(?N,?pos)).
-define(post_process(N), post_process(N,?pos)).
post_process(AST, Pos) ->
  {Attrs, Funs} = lists:partition(fun(V)->element(1,V) == attribute end, lists:flatten(AST)),
  {Funs2, Avail, Exports, Inlines} = grouped_funs(Funs),
  Attrs2 = fix_exports(Attrs, Exports, Avail),
  {ok, Attrs2 ++ Funs2, Pos}.


% Takes the arbitrarily grouped functions and groups them in a way that erlang
% expects them- by name/arity.
grouped_funs(Funs) -> grouped_funs(Funs, [], [], [], []).
grouped_funs([],FunsAcc,AvailAcc,ExportAcc,InlineAcc)->{?rev(FunsAcc),AvailAcc,ExportAcc,InlineAcc};
grouped_funs([{_,FirstPos,AN,AA,_} | _] = Remaining, FunsAcc, AvailAcc, ExportAcc, InlineAcc) ->
  {FunGroup, Remaining2} = lists:partition(
    fun({_,_,BN,BA,_})-> {?v_atom(AN),AA}=={?v_atom(BN),BA} end,
    Remaining),
  Clauses = [C || {_,_,_,_,C} <- FunGroup],
  Fun = {function, FirstPos, ?v_atom(AN), AA, Clauses},
  grouped_funs(Remaining2, [Fun | FunsAcc], [{?v_atom(AN),AA}|AvailAcc],[],[]).

% Takes implied exports and explicit export attributes and puts them into
% a single export attribute that's in the format Erlang loves.
fix_exports(Attrs, Exports, Avail) ->
  {Exps, Attrs2} = find_exports(Attrs, [], []),
  AllExports = Exps ++ Exports,
  ExpandedExports = expanded_exports(AllExports, Avail),
  ExpandedExports ++ Attrs2.

% Extract export statements and separate them out (for line-number on errors)
find_exports([],Found,Attr) -> {?rev(Found), ?rev(Attr)};
find_exports([{attribute, Pos, export, L}|R], Found, Attr) ->
  Separated = [{attribute,Pos,export,LI} || LI <- L],
  find_exports(R, Separated ++ Found, Attr);
find_exports([O|R], Found, Attr) ->
  find_exports(R, Found, [O | Attr]).

% Reformat atoms into all versions of that function if it exists, and reformat all
% funsigs into the format that erlang expects ({Name,Arity}).
expanded_exports(Exps, Avail) -> expanded_exports(Exps, Avail, []).
expanded_exports([],_Avail,Acc) -> ?rev(Acc);
expanded_exports([{attribute, _, export, {atom,Pos,What}}|R],Avail,Acc) ->
  expanded_exports(R,Avail,[{attribute,Pos,export,availables(Avail, What, [], Pos)}|Acc]);
expanded_exports([{attribute, _, export, {'fun',Pos,{function,Name,Arity}}}|R],Avail,Acc) ->
  expanded_exports(R,Avail,[{attribute,Pos,export,[{Name,Arity}]}|Acc]);
expanded_exports([{attribute, Pos, export, Err}|_],_,_) ->
  ?halt_error(Pos, "Unknown export type", Err, ?EXPORT_EXAMPLE).

% Look through list of available functions of one with this name and return
% all of them (with their arities, ready for the export statement)
availables([],Find,[], Pos) ->
  ?halt_error(Pos, "Exporting undefined function", Find, ?EXPORT_EXAMPLE);
availables([],_,Acc, Pos)              -> ?rev(Acc);
availables([{Find,Arity}|R],Find,Acc,P)-> availables(R,Find,[{Find,Arity}|Acc],P);
availables([_|R],Find,Acc,P)           -> availables(R,Find,Acc,P).


% vim: set noai filetype=erlang textwidth=100:
`
