%------------ Grammar --------------------------------------------------------
grammar       <- (_s form)* _s                        `{ok, ?ip2(?p1), ?pos}`;
form          <- attribute / function                                       ~;

%------------ Attributes -----------------------------------------------------
attribute     <- module                                        `{attr, Node}`;
module        <- "@module" sp atom                                      `?p3`;

%------------ Functions ------------------------------------------------------
function      <- atom clauses                           `?c_function(?p1,?p2)`;

%------------ Clauses --------------------------------------------------------
clauses       <- clauseblock / clause                              `?listify`;
clause        <- _s "|"? pattern? guardseq? _s "->" expressions     `?clause`;
clauseblock   <- sblock clause+ eblock                                  `?p2`;

pattern       <- (_s term)+                                            `?ip2`; % TMP
guardseq      <- _s "||" (_s guard_expr)*                         `?ip2(?p3)`; % TMP
guard_expr    <- (_s term)+                                            `?ip2`; % TMP

%------------ Expressions ----------------------------------------------------
% This may look confusing because of the explicit blocks (exp_block) vs.
% normal blocks (block).  Normal blocks don't have "begin ... end"- but if a
% block suddenly starts in the middle of a bunch of expressions, it does get
% a begin...end (that's the exp_block).
expressions   <- expression+                                          `?flat`;
expression    <- _s (block / expr_with_end)                             `?p2`;
inner_exp     <- _s (exp_block / expr_with_end)                         `?p2`;
exp_block     <- sblock inner_exp* expr? eblock     `?c_block(?app(?p2,?p3))`;
block         <- sblock inner_exp* expr? eblock               `?app(?p2,?p3)`;
expr_with_end <- expr eos                                               `?p1`;
expr          <- term                                                       ~;

%------------ Terms / Atomic Literals ----------------------------------------
term          <- string / atom / number / tuple                             ~;

atom          <- simple_atom / complex_atom                           `?scan`;
simple_atom   <- [a-z] [a-z0-9_@?]*                            `[$',Node,$']`;
complex_atom  <- "'" not_apos* "'"                                          ~;
not_apos      <- !"'" ("\\" . / !"\\" .)                                `?p2`;

number        <- [+-]? (float / integer)                            `?fixnum`;
integer       <- base_int / normal_int / character                          ~;
normal_int    <- [0-9] [0-9_]*                                              ~;
base_int      <- base_prefix [A-Za-z0-9_]+                                  ~;
base_prefix   <- "0" [xX] / "0" [oO] / "0" [bB] / ([1-9] [0-9]* [rR]) `?base`;
character     <- "$" (char_escapes / .)                                     ~;
char_escapes  <- "\\^" [a-zA-Z] / "\\" o (o o?)? / "\\x{" h+ "}" /
                 "\\x" h h / "\\" .                                         ~;
o             <- [0-7]                                                      ~;
h             <- [0-9a-fA-F]                                                ~;
float         <- normal_int "." normal_int+ ([eE] [-+]? normal_int)?        ~;

string        <- (_s string_part)+                              `?cats(?ip2)`;
string_part   <- simple_string / long_string                          `?scan`;
simple_string <- '"' not_quot* '"'                                          ~;
not_quot      <- !'"' ("\\" . / !"\\" .)                                `?p2`;
long_string   <- "'''" not_triple_ap* "'''"                   `?fixlstr(?p2)`;
not_triple_ap <- !"'''" ("\\" "'''" / "\\" . / !"\\" .)                 `?p2`;

%------------ Tuples & Lists -------------------------------------------------
tuple         <- _s "(" _s term_sequence _s ")"               `?inspect(?p4)`;
term_sequence <- empty_ts / comma_ts                   ~;
%term_sequence <- empty_ts / comma_ts / pipe_ts / space_ts                   ~;
empty_ts      <- ws                                                      `[]`;
comma_ts      <- term (_s "," _s term)*                    `[?p1]++?ip4(?p2)`;


%------------ Whitespace, Comments, Delimiters -------------------------------
sblock        <- _s ("{" _s indent / indent _s "{" / "{" / indent)       `?X`;
eblock        <- _s ("}" _s dedent / dedent _s "}" / "}" / dedent)       `?X`;
indent        <- "\x06"                                                  `?X`;
dedent        <- "\x15"                                                  `?X`;
eos           <- _sp (";" / newline / !.)                                `?X`;
_s            <- ws?                                                     `?X`;
ws            <- (space / newline)+                                      `?X`;
newline       <- comment? "\n" / "\r\n" / "\r"                           `?X`;
_sp           <- sp?                                                     `?X`;
sp            <- space+                                                  `?X`;
space         <- [ \t] / ml_comment                                      `?X`;
comment       <- "#" (!newline .)* &newline                              `?X`;
ml_inner      <- ml_comment / (!"#|" !"|#" .)+                           `?X`;
ml_comment    <- "#|" ml_inner* "|#"                                     `?X`;

%------------ Shortcuts & transformations ------------------------------------
`
% Common macros
-include("../include/ungbar.hrl").

% Macros that are specific to this grammar

% Functions
-define(clause, ?clause(?N)).
-define(clause(N),
  begin
      [_, _, Pattern, Guard, _, _, Body] = N,
      % TODO: turn type declarations into parts of the guard
      ?c_clause(Pattern,Guard,?listify(Body))
  end).

% Numbers
-define(base,   base(?N)).
-define(fixnum, fix_num(?N, ?I)).

base(["0",$X])->"16#";
base(["0",$x])->"16#";
base(["0",$O])->"8#";
base(["0",$o])->"8#";
base(["0",$B])->"2#";
base(["0",$b])->"2#";
base([D1, DN, $R]) -> [?flat([D1,DN,"#"])];
base([D1, DN, $r]) -> [?flat([D1,DN,"#"])].

% Flatten, remove underscores and positive signs, scan, and then apply
% negative sign if necessary.
fix_num(Node,Index)      ->fix_num2(rm_char($_,rm_char($+,?flat)), Index).
fix_num2([$-|Node],Index)->{T,L,V}=?scan, {T,L,-V};
fix_num2(Node,Index)     ->?scan.


% Strings
% Not really necessary usually (epp does this as well) - but I think it's safer
% here anyway: concatenate strings that are in a sequence.
-define(cats, ?cats(?N)).
-define(cats(Ss), erl_parse:abstract(?flat(lists:append([erl_parse:normalise(S)||S<-Ss])))).

-define(fixlstr, ?fixlstr(?N)).
-define(fixlstr(N), ["\"", rm_char($","\\\"",?flat(N)), "\""]).


rm_char(C,L)      ->rm_char(C,[],L,[]).
rm_char(C,R,L)    ->rm_char(C,R,L,[]).
rm_char(_,_,[],A)   ->?flat(lists:reverse(A));
rm_char(C,R,[C|T],A)->rm_char(C,R,T,[R|A]);
rm_char(C,R,[H|T],A)->rm_char(C,R,T,[H|A]).

% vim: set noai filetype=erlang textwidth=100:
`
