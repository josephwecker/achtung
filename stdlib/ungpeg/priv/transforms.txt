# Rewrite rules for extended
# TODO: bytestrings & bitstrings


#------------------------ Definitions ----------------------------------------|
#exp   :: ord | xrd | seq | ref | lit | chr | any

#ord   :: [exp]
#xrd   :: [exp]
#seq   :: [exp]
#lit   :: [utf]

#ref   ::
#chr   :: [ccr]
#any   :: {utf}
#utf   :: {x: x is a valid UTF-8 codepoint}
#range :: (+|-, utf | (utf,utf))


#------------------------ Aliases --------------------------------------------|
SEQ ~ (P seq S)
PCH ~ (P pch S)
XCH ~ (P xch S)
LIT ~ (P lit S)
CHR ~ (P chr S)
REF ~ (P ref S)
Ɛ   ~ (P ɛ S)
Ϝ   ~ (P ϝ S)

αchr ~ ([] chr [])
αlit ~ ([] lit [])
αϝ   ~ ([] ϝ [])
#Ø

#------------------------ Rewrite Rules --------------------------------------|
┊
┊

┋
┋

│
│

╎
╎
╎
╎

║
║
║
║
║
║

⁑
⁑
⁝
⁝
⁝
•
•
⸏
_
⸐
⁜
⁘
‖
⸖
### Simplification: Dead sequence removal
### A ϝ term anywhere in a seq causes the whole thing to fail
### A B ϝ D → ϝ
(Seq <αϝ>) →                                   |w'Sequence always fails'| ϝ |

### Simplification: Sequence NOP removal
### ɛ anywhere in a sequence doesn't do anything
### A B ɛ C → A B C
(Seq <([] ɛ [])|R]) →                                                (Seq <R])

### Simplification: Dead choice short circuit
### Anything after an ɛ in an ord or xrd is unreachable
### A/B/ɛ/C/D → A/B/ɛ
(Ord <ɛ|R]) →                                |w'Unreachable code'| (Ord <ɛ]) |
(Xrd <ɛ|R]) →                                |w'Unreachable code'| (Xrd <ɛ]) |

### Simplification: NOP Choice removal
### A term in an ord/xrd that is guaranteed to fail can be skipped
### A/B/ϝ/C/D → A/B/C/D
(Ord <ϝ|R]) →                                                        (Ord <R])
(Xrd <ϝ|R]) →                                                        (Xrd <R])

### Simplification: Inline subgroup
### seq, ord, and xrd are associative, and inner terms of the same type
### A·(B·C)·D → A·B·C·D
(M <(([] M []) B)>) →                                                  (M <B>)

### Simplification: Inline single
### An ord/xrd/seq is just the term (with attributes combined)
### A (B*)? C → A B*? C
((P1 M1 S1) [((P2 E S2) B)]) →                           ((P1++P2 E S1++S2) B)

### Expansion: Literal removal
### Transform literal into sequence of character classes (after several
###   applications)
### 'abc' →[a] 'bc'
(Lit [C|R]) →                                        (Seq [(𝛼chr C) (𝛼lit R)])

### Simplification: Empty literal
### By definition
### '' →ɛ
(Lit []) →                                                                   ɛ

### Simplification: Empty character class
### By definition
### [] →ɛ
(Chr C) : C = {} →                                                           ɛ

### Simplification: Merge character classes
### If one character class is to be tried and then another, try them at the
###   same time instead.
### A/B/[0-9]/[x]/C → A/B/[0-9x]/C
(Ord <(chr C1) (chr C2)>) →                               (ord <(chr C1∪C2)>)
(Xrd <(chr C1) (chr C2)>) →                               (xrd <(chr C1∪C2)>)

### 


#(Seq <((P E



(seq <!(chr C) (chr Sub)>) : C ⊇ Sub →                                      ϝ
(seq <!(chr C1) (chr C2)>) →                               (seq <(chr C1∖C2)>)
(seq <&(chr C1) (chr C2)>) : C1∩C2 = {}→                                    ϝ
(seq <&(chr C1) (chr C2)>) →                              (seq <(chr C1∩c2)>)

