# Rewrite rules for extended
# TODO: bytestrings & bitstrings


#------------------------ Definitions ----------------------------------------|
#exp   :: ord | xrd | seq | ref | lit | chr | any

#ord   :: [exp]
#xrd   :: [exp]
#seq   :: [exp]
#lit   :: [utf]

#ref   ::
#chr   :: [ccr]
#any   :: {utf}
#utf   :: {x: x is a valid UTF-8 codepoint}
#range :: (+|-, utf | (utf,utf))


#------------------------ Aliases --------------------------------------------|
SEQ ~ (P seq S)
PCH ~ (P pch S)
XCH ~ (P xch S)
LIT ~ (P lit S)
CHR ~ (P chr S)
REF ~ (P ref S)
Æ   ~ (P É› S)
Ïœ   ~ (P Ï S)

Î±chr ~ ([] chr [])
Î±lit ~ ([] lit [])
Î±Ï   ~ ([] Ï [])
#Ã˜

#------------------------ Rewrite Rules --------------------------------------|
â”Š
â”Š

â”‹
â”‹

â”‚
â”‚

â•
â•
â•
â•

â•‘
â•‘
â•‘
â•‘
â•‘
â•‘

â‘
â‘
â
â
â
â€¢
â€¢
â¸
_
â¸
âœ
â˜
â€–
â¸–
### Simplification: Dead sequence removal
### A Ï term anywhere in a seq causes the whole thing to fail
### A B Ï D â†’ Ï
(Seq <Î±Ï>) â†’                                   |w'Sequence always fails'| Ï |

### Simplification: Sequence NOP removal
### É› anywhere in a sequence doesn't do anything
### A B É› C â†’ A B C
(Seq <([] É› [])|R]) â†’                                                (Seq <R])

### Simplification: Dead choice short circuit
### Anything after an É› in an ord or xrd is unreachable
### A/B/É›/C/D â†’ A/B/É›
(Ord <É›|R]) â†’                                |w'Unreachable code'| (Ord <É›]) |
(Xrd <É›|R]) â†’                                |w'Unreachable code'| (Xrd <É›]) |

### Simplification: NOP Choice removal
### A term in an ord/xrd that is guaranteed to fail can be skipped
### A/B/Ï/C/D â†’ A/B/C/D
(Ord <Ï|R]) â†’                                                        (Ord <R])
(Xrd <Ï|R]) â†’                                                        (Xrd <R])

### Simplification: Inline subgroup
### seq, ord, and xrd are associative, and inner terms of the same type
### AÂ·(BÂ·C)Â·D â†’ AÂ·BÂ·CÂ·D
(M <(([] M []) B)>) â†’                                                  (M <B>)

### Simplification: Inline single
### An ord/xrd/seq is just the term (with attributes combined)
### A (B*)? C â†’ A B*? C
((P1 M1 S1) [((P2 E S2) B)]) â†’                           ((P1++P2 E S1++S2) B)

### Expansion: Literal removal
### Transform literal into sequence of character classes (after several
###   applications)
### 'abc' â†’[a] 'bc'
(Lit [C|R]) â†’                                        (Seq [(ğ›¼chr C) (ğ›¼lit R)])

### Simplification: Empty literal
### By definition
### '' â†’É›
(Lit []) â†’                                                                   É›

### Simplification: Empty character class
### By definition
### [] â†’É›
(Chr C) : C = {} â†’                                                           É›

### Simplification: Merge character classes
### If one character class is to be tried and then another, try them at the
###   same time instead.
### A/B/[0-9]/[x]/C â†’ A/B/[0-9x]/C
(Ord <(chr C1) (chr C2)>) â†’                               (ord <(chr C1âˆªC2)>)
(Xrd <(chr C1) (chr C2)>) â†’                               (xrd <(chr C1âˆªC2)>)

### 


#(Seq <((P E



(seq <!(chr C) (chr Sub)>) : C âŠ‡ Sub â†’                                      Ï
(seq <!(chr C1) (chr C2)>) â†’                               (seq <(chr C1âˆ–C2)>)
(seq <&(chr C1) (chr C2)>) : C1âˆ©C2 = {}â†’                                    Ï
(seq <&(chr C1) (chr C2)>) â†’                              (seq <(chr C1âˆ©c2)>)

