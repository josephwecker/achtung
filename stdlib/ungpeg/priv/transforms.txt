# Rewrite rules for extended
# TODO: bytestrings & bitstrings


#------------------------ Definitions ----------------------------------------|
#exp   :: ord | xrd | seq | ref | lit | chr | any

#ord   :: [exp]
#xrd   :: [exp]
#seq   :: [exp]
#lit   :: [utf]

#ref   ::
#chr   :: [ccr]
#any   :: {utf}
#utf   :: {x: x is a valid UTF-8 codepoint}
#range :: (+|-, utf | (utf,utf))


#------------------------ Aliases --------------------------------------------|
SEQ ~ (Ps seq Ss)
PCH ~ (Pp pch Sp)
XCH ~ (Px xch Sx)
LIT ~ (Pl lit Sl)
CHR ~ (Pc chr Sc)
REF ~ (Pr ref Sr)
Æ   ~ (Pe É› Se)
Ïœ   ~ (Pf Ï Sf)

E1 ~ (Pe1 ET1 Se1)
E2 ~ (Pe2 ET2 Se2)

Î±chr ~ ([] chr [])
Î±lit ~ ([] lit [])
Î±Ï   ~ ([] Ï [])
Î±É›   ~ ([] É› [])
Î±e1  ~ ([] ET1 [])
Î±e2  ~ ([] ET1 [])
#Ã˜

#------------------------ Rewrite Rules --------------------------------------|
'Dead sequence removal (Simplification)'
### A Ï term anywhere in a seq causes the whole thing to fail
### A B Ï D â†’ Ï
(Seq <Î±Ï>) â†’                                   |w'Sequence always fails'| Ï |

'Sequence NOP removal (Simplification)'
### É› anywhere in a sequence doesn't do anything
### A B É› C â†’ A B C
(Seq <([] É› [])|R]) â†’                                                (Seq <R])

'Dead choice short circuit (Simplification)'
### Anything after an É› in an ord or xrd is unreachable
### A/B/É›/C/D â†’ A/B/É›
(Ord <É›|R]) â†’                                |w'Unreachable code'| (Ord <É›]) |
(Xrd <É›|R]) â†’                                |w'Unreachable code'| (Xrd <É›]) |
# TODO: When formalizing this syntax- remember that ..A|R] implies R != []
# otherwise you'd write ..A]

'NOP Choice removal (Simplification)'
### A term in an ord/xrd that is guaranteed to fail can be skipped
### A/B/Ï/C/D â†’ A/B/C/D
(Ord <Ï|R]) â†’                                                        (Ord <R])
(Xrd <Ï|R]) â†’                                                        (Xrd <R])

'Inline like-subgroup (Simplification)'
### seq, ord, and xrd are associative, and inner terms of the same type
### AÂ·(BÂ·C)Â·D â†’ AÂ·BÂ·CÂ·D
(E1 <(Î±e1 B)>) â†’                                                     (E1 <B>)

'Inline orphan (Simplification)'
### An ord/xrd/seq is just the term (with attributes combined)
### A (B*)? C â†’ A B*? C
((P1 M1 S1) [((P2 E S2) B)]) â†’                           ((P1++P2 E S1++S2) B)

### Expansion: Literal removal
### Transform literal into sequence of character classes (after several
###   applications)
### 'abc' â†’[a] 'bc'
(Lit [C|R]) â†’                                        (Seq [(ğ›¼chr C) (ğ›¼lit R)])

### Simplification: Empty literal
### By definition
### '' â†’É›
(Lit []) â†’                                                                   É›

### Simplification: Empty character class
### By definition
### [] â†’É›
(Chr C) : C = {} â†’                                                           É›

### Simplification: Merge character classes
### If one character class is to be tried and then another, try them at the
###   same time instead.
### A/B/[0-9]/[x]/C â†’ A/B/[0-9x]/C
(Ord <(chr C1) (chr C2)>) â†’                               (ord <(chr C1âˆªC2)>)
(Xrd <(chr C1) (chr C2)>) â†’                               (xrd <(chr C1âˆªC2)>)

### 


#(Seq <((P E



(seq <!(chr C) (chr Sub)>) : C âŠ‡ Sub â†’                                      Ï
(seq <!(chr C1) (chr C2)>) â†’                               (seq <(chr C1âˆ–C2)>)
(seq <&(chr C1) (chr C2)>) : C1âˆ©C2 = {}â†’                                    Ï
(seq <&(chr C1) (chr C2)>) â†’                              (seq <(chr C1âˆ©c2)>)

