
% Alias definition
% Tuple
% List Abbreviation
% Mapping-name / title (optional)
% Mapping
% Mapping qualifier
% Message generator
% Comments / whitespace

%------------ Grammar -------------------------------------------------------|
forms         <- (_s mapping)* _s                         `{ok,?pos,?i(1,2)}`; 

%------------ Rewrite Rules -------------------------------------------------|
mapping       <- name rw_clauses                     `{mapping,?pos,?p1,?p2}`;
name          <- chained_atom / atom                                        ~;

%------------ Clauses -------------------------------------------------------|
rw_clauses    <- rwclause+                                         `?listify`;
rwclause      <- _s "|" rw_expr _s match_qual?
                 _s ENTAILS rw_expr             `{rwclause,?pos,?p3,?p5,?p8}`;
match_qual    <- !ENTAILS "|" (_s guard_expr)*                      `?i(3,2)`;

%------------ Expressions ---------------------------------------------------|
guard_expr    <- _s atom                                                `?p2`; % TMP
rw_expr       <- _s (r_tuple / r_list / atom / r_variable)              `?p2`;

%------------ Terms ---------------------------------------------------------|
chained_atom  <- atom ("/" atom)*                             `[?p1|?i(2,2)]`;
atom          <- simple_atom / complex_atom                           `?scan`;
simple_atom   <- [a-z] [a-zA-Z0-9_@?]*                         `[$',Node,$']`;
complex_atom  <- "'" not_apos* "'"                                          ~;
not_apos      <- !"'" ("\\" . / !"\\" .)                                `?p2`;

r_variable    <- [A-Z_@] [A-Za-z0-9?_]*                              `?c_var`;


%------------ Tuples & Lists -------------------------------------------------
r_tuple       <- _s (empty_t / r_comma_t / r_space_t)         `?c_tuple(?p2)`;
r_comma_t     <- "(" _s rw_expr (_s "," _s rw_expr)* _s ")"   `[?p3|?i(4,4)]`;
r_space_t     <- "(" _s rw_expr (sd rw_expr)* _s ")"          `[?p3|?i(4,2)]`;
r_list        <- _s (empty_l / r_comma_l / r_space_l)          `?c_list(?p2)`;
r_comma_l     <- "[" _s rw_expr (_s "," _s rw_expr)* _s r_t? "]" `{[?p3|?i(4,4)],?p6}`;
r_space_l     <- "[" _s rw_expr (sd rw_expr)* _s r_t? "]"        `{[?p3|?i(4,2)],?p6}`;
r_t           <- "|" _s rw_expr _s                                      `?p3`;
empty_l       <- "[" _s "]"                                              `[]`;
empty_t       <- "(" _s ")"                                              `[]`;

%------------ Whitespace, Comments, Delimiters ------------------------------|
ENTAILS       <- "âŠ§" / "|=" / "="                                        `?X`;
_s            <- s?                                                      `?X`; % Optional whitespace
sd            <- ( "\\"? (space / nl) )+                                 `?X`; % Space delimiter
s             <- (space / nl)+                                           `?X`; % At least one whitespace/newline
nl            <- comment? newline                                        `?X`; % End of a line

newline       <- "\n" / "\r\n" / "\r"                                    `?X`;
space         <- [ \t] / ml_comment                                      `?X`;
comment       <- "#" (!newline .)* &newline                              `?X`;
ml_inner      <- ml_comment / (!"#|" !"|#" .)+                           `?X`;
ml_comment    <- "#|" ml_inner* "|#"                                     `?X`;

%--- from old ungbar. possibly useful later

%_sp           <- sp?                                                     `?X`; % Optional spacing (no newline)
%sp            <- space+                                                  `?X`; % At least one space (not newline)
%sblock        <- _s ("{" _s indent / indent _s "{" / "{" / indent) _s    `?X`;
%eblock        <- _s ("}" _s dedent / dedent _s "}" / "}" / dedent) _s    `?X`;
%eos           <- _sp (";" / nl / !.)                                     `?X`; % End of a statement
%eol           <- _sp ";"? (nl _s / &eblock / !.)                         `?X`; % End of a expression line
%indent        <- "\x06"                                                  `?X`;
%dedent        <- "\x15"                                                  `?X`;


`
%------------ Misc Helpers --------------------------------------------------|
-compile({nowarn_unused_function, [{rm_char,3},{rm_char,4}]}).
-define(X, []). % Consume but ignore
-define(I, Index).
-define(inspect, ?inspect(?N)).
-define(inspect(N), begin io:format("~n====== inspect =======~n~p~n"
        "======================~n", [N]), N end).

-define(listify, ?listify(?N)). % Ensure it's a list
-define(listify(V), case V of [_|_]->V;_->[V] end).
-define(idx, {line(Index),column(Index)}).
-define(N, Node).
-define(pos, line(Index)).
-define(e1, ?e1(?N)).
-define(e2, ?e2(?N)).
-define(e3, ?e3(?N)).
-define(p1, ?p1(?N)).
-define(p2, ?p2(?N)).
-define(p3, ?p3(?N)).
-define(p4, ?p4(?N)).
-define(p5, ?p5(?N)).
-define(p6, ?p6(?N)).
-define(p7, ?p7(?N)).
-define(p8, ?p8(?N)).
-define(flat, ?flat(?N)).
-define(rev, ?rev(?N)).
-define(e1(T), element(1,T)).
-define(e2(T), element(2,T)).
-define(e3(T), element(3,T)).
-define(p1(L), lnth(1,L)).
-define(p2(L), lnth(2,L)).
-define(p3(L), lnth(3,L)).
-define(p4(L), lnth(4,L)).
-define(p5(L), lnth(5,L)).
-define(p6(L), lnth(6,L)).
-define(p7(L), lnth(7,L)).
-define(p8(L), lnth(8,L)).
-define(i(OPos,IPos), [lnth(IPos, IL)||IL<-lnth(OPos,?N)]).
-define(flat(L), lists:flatten(L)).
-define(rev(L), lists:reverse(L)).
-define(scan,?scan(?N)).
-define(scan(V), % For simple terms that the erlang scanner can handle (most atomic literals)
  case erl_scan:string(?flat(V),?pos) of
    {ok, [One], _} -> element(3,One);
    {ok, Tokens, _} ->
      {ok, Parsed} = erl_parse:parse_term(Tokens ++ [{dot,?pos}]),
      Abs = erl_parse:abstract(Parsed), io:format("~p~n",[Parsed]);
    Err -> throw(Err)
  end).
-define(c_tuple(Items), {tuple, ?pos, Items}).
-define(c_list(IT),case IT of []->?c_nil;{I,T}->l2c(I,T,?pos) end).
-define(c_nil, {nil,?pos}).
-define(c_var, ?c_var(?N)).
-define(c_var(Name), {var,?pos,list_to_atom(?flat(Name))}).

% List to Conses - basically recursively (not tail recursively at the moment)
% takes a proper list with a tail (usually [] when the result is going to be
% proper) and turns it into nested cons tuples.
% Usage: l2c(ProperList, TailForEnd, Position)
l2c([H|R],T,Pos) ->
  {cons, Pos, H,
    case R of
      []->  % Done with main proper-list, time for tail
        case T of
          [] -> {nil,Pos};    % Final result is proper
          V  -> V             % Final result is improper
        end;
      [_|_] -> l2c(R, T, Pos) % Keep going deeper. I hope your stack loves you.
    end}.

lnth(Pos, L) ->
  case (catch lists:nth(Pos,L)) of
    {'EXIT',_}->[];
    O->O
  end.

-define(fixlstr, ?fixlstr(?N)).
-define(fixlstr(N), ["\"", rm_char($","\\\"",?flat(N)), "\""]).
% Remove (or replace) a character
%rm_char(C,L)        ->rm_char(C,[],L,[]).
rm_char(C,R,L)      ->rm_char(C,R,L,[]).
rm_char(_,_,[],A)   ->?flat(?rev(A));
rm_char(C,R,[C|T],A)->rm_char(C,R,T,[R|A]);
rm_char(C,R,[H|T],A)->rm_char(C,R,T,[H|A]).
% vim: set noai filetype=erlang textwidth=100:
`
