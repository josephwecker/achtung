#|e  <- T:f+ [@] V:f+ -> $T $V
f  <- [a-z] [0-9]

e  <=- [a-z] [0-9] -{e-T} s1
s1 <=- [a-z] [0-9] -{e-T} s1 ║ [@]-{~} [a-z] [0-9] -{e-V} s2
s2 <=- [a-z] [0-9] -{e-V} s2 ║ ɛ-{|($T $V)|}

a/b/c
a⌿b⌿c
a⑊b⑊c /d/e
e ← [a] e / [a]
⌿/
e <= [a] e-{|e|} / [a]-{|e|} ʃ 
|#


yield: finishes and returns context
eof:   matches end of input
fin:   eof if no characters left, otherwise yield
-----

e ← ([a] e [b] / [c]) fin   || (1)
# Informally: a{n}> c <b{n}
e ← ([a] e [b] / [a]) fin   || (2)
# Informally: a{n}> a <b{n}
e ← ([a] e [a] / [a]) fin   || (3)
# Informally: a{n}> a <a{n}

#*** {n} means run that many times successfully- not necessarily # consumed.

e ← ([a] e [b] / [c]) fin   || (1)
=> 'c' | 'acb' | 'aacbb' | 'aaacbbb'
/> 'acba' | 'ab'


{{'a','c'}}
if i[1,()]='a' → left  IOU('a',__) {{'a','c'}}
if i[1,()]='c' → right {{fin}}

{{'a','c'}}
if i[2,('a',__)]='a' → left  PAY('a',('a',__)) {{'a','b','c'}}
if i[2,('a',__)]='c' → right PAY('a','c') {{'b'}}


# Informally: a{n}> c <b{n}
=>> 'acb'
i1{'a',1,[]} →Left side only




---------------
e ← [a] [b] [c]-{left} / [a] [b]-{right}
  ← [a] [b] ([c]-{left} / -{right})


e ← v:([a] e [a] / [a]) fin →$v
  ← [a] e [a]-{v} fin-{|e|} / [a]-{v} fin-{|e|}
  ← [a]   (e [a] {v} fin {|e|} ⑊ ɛ {v} fin {|e|})

  ← [a]   (e [a] {v} fin {|e|} ⑊ fin {v} {|e|})  # Collapse can move to the right of non-consuming

  ← [a]   (e [a] fin {v} {|e|} ⑊ fin {v} {|e|})
      ok    ^                     ^
#           This one?             Or this one? - I need as many finishes as starts + 1


--------------

R←a R a / a →$_

 ←a R a《R》
  /a《R》

 ←a (a R a《R》/ a《R》) R a《R》
  /a《R》

 ←a (a R a《R》/ a《R》) R a《R》
  /a《R》

---------------
R ← a R a / a
I1='a'
(i1,'a',[]) => succ on left


a a a a a a a a a

(a(a(a(a(a(a(a(a(a(
                   ^
(a(a(a(a(a(a(a(a(a)
                 ^
(a(a(a(a(a(a(a(a)a)
               ^
(a(a(a(a(a(a(a)a)a)
             ^
(a(a(a(a(a(a)a)a)a)
           ^
(a(a(a(a(a)a)a)a)a)    < If next is fin
         ^
fin after a*0|→            (_)ϝ
fin after a*1|→            (a)
fin after a*2|→      (a (a) _) ϝ
fin after a*3|→      (a (a) a)
fin after a*4|→(a (a (a) a) _) ϝ
fin after a*5|→(a (a (a) a) a)

Shift left if equivalency in suffix/prefix according to deterministic nature of
the `pch` and `xch` terms.

i2 ∊ fin, a+promise

At any given time- three possible next actions:

R  ← left R right / middle

R` ← left{*i} 〈N=i〉middle right{N}




--------------------


If the results are not going to be consumed, then probably most of this can be
skipped in leueue of counters.





--------------------
b ← aaa/aa/a
  ← a(aa/a/ɛ)
  ← a(a(a/ɛ)/ɛ) 

R ← aRaaa / aaR / a
  ← a (Raaa / aR / ɛ)
        ^       
        ------------------
  #← a(a(Raaa / aR / ɛ) aaa / aR / ɛ)
  ← a(a((Raaa / aR / ɛ) aaa / R) / ɛ)

n0: ϝ
n1: (a)                  3
n2: ϝ
n3: (a a (a))            2(3)
n4: ϝ
n5: (a (a) a a a)        1(3)
n6: ϝ
n7: (a (a a (a)) a a a)  1(2(3))
n8: 
