--------------------------------------------

S <- (' '/'\t'/'\n'/'\r')*
S <-- star1
star1 <-- ([ ]/[\t]/[\n]/[\r]) star1 / succ
# TODO: Need a rule/transform to make sure star1 swaps into place of S
#  done: see NOTE ON STAR REDUCTION IN PLACE below

S | [ ]  |-> S
  | [\t] |-> S
  | [\n] |-> S
  | [\r] |-> S
  | _    |-> succ


--------------------------------------------

number    <- int frac? exp?                                ->      (num $1 $2)
int       <- d:'-'? (d:nz_digit d:digit+) / d:digit        ->               $d
frac      <- '.' digit+                                    ->        (frac $2)
exp       <- e digit+                                      ->        (e $e $2)
e         <- [eE] ('+' / '-')?                             ->               $2
nz_digit  <- [1-9]
digit     <- [0-9]

number <- 1-number:(d-int:[-]? (d-int:[1-9] d-int:([0-9] [0-9]*)) / d-int:[0-9])
          2-number:([.] 2-frac:([0-9] [0-9]*))?
	  (e-exp:(([e]/[E]) 2-e:([+]/[-])?) 2-exp:([0-9] [0-9]*))?

number <- ([-]? [1-9] [0-9] [0-9]* / [0-9])
          ([.] [0-9] [0-9]*)?
	  (([e]/[E]) ([+]/[-])? [0-9] [0-9]*)?

number <- ( ([-] [1-9] [0-9] [0-9]*) /
            ([1-9] [0-9] [0-9]*) /
	    [0-9]
	  )
	  ([.] ...)
	  ([e] ...)
	  ([E] ...)
	  (_ -> succ)


== non-labeled & no transforms/collapse ==

number  | [-]         |-> [1-9] [0-9] star1 number2
        | [1-9] [0-9] |-> star1 number2             # Overlap so second one necessary
        | [0-9]       |-> number2                   # Overlap with previous
	| _           |-> fail

number2 | [.]         |-> [0-9] star1 number3
        | _           |-> number3

number3 | [eE] [+]    |-> [0-9] star1 succ
        | [eE] [-]    |-> [0-9] star1 succ
        | [eE] [0-9]  |-> star1 succ
        | _           |-> succ

star1   | [0-9]       |-> star1
([0-9]*)| _           |-> succ

# TODO: possibly automatically abstract out common runs if there are enough of
# them / they are big enough to warrant it. (e.g., 'star1 succ')

# TODO: actually, star1 is guaranteed to succeed, so star1 succ is redundant-
# except collapse and transformations may affect it.

# Technically you can pull 4 bytes out at once and jump that far into the
# stream, but in reality there are so many choices by then that the decision
# logic and program size would undo any benefits...
[-]   [1-9] [0-9] [0-9] -> [0-9]*
[-]   [1-9] [0-9] [.]   -> ...
[-]   [1-9] [0-9] [eE]  -> ...
[-]   [1-9] [0-9] _     -> succ
[1-9] [0-9] [0-9] [0-9] -> [0-9]*
[1-9] [0-9] [0-9] _     -> succ
[1-9] [0-9] _     _     -> succ
...
# So the rule is: Pull the least amount possible that allows you to branch.(?)

--------------------------------------------

comment_lang  <- S* 'hi!' S*
S             <- (SPACE / NL)+
NL            <- COMMENT? NEWLINE
NEWLINE       <- "\n" / "\r\n" / "\r"
SPACE         <- [ \t] / ML_COMMENT
COMMENT       <- "#" (!NEWLINE .)* &NEWLINE
ML_INNER      <- ML_COMMENT / (!"#|" !"|#" .)+
ML_COMMENT    <- "#|" ML_INNER* "|#"

comment_lang <-- star1 'hi!' star1
ML_COMMENT   <-- '#|' (ML_COMMENT / (!('#|'/'|#') any) (!('#|'/'|#') any)*)* '|#'
star1        <-- ([ ] / [\t] / ML_COMMENT / ([#] (!([\n]/'\r\n'/[\r]) any)* &([\n]/'\r\n'/[\r]))? ([\n]/'\r\n'/[\r])) star1 / succ


comment_lang| _    |-> star1 'hi!' star1
star1       | [


--------------------------------------------

e <- f1 f2 f3

f1 <- e1 / e2 / e3
f2 <- e1 e2 e3
f3 <- e1? e2 e3 #== e1 e2 e3 / e2 e3

e1 <- t1 t2 t3
e2 <- t1 / t2 / t3
e3 <- t1? t2 / t3 #== t1 t2 / t2 / t3

t1 <- [a]
t2 <- 'bcd'
t3 <- [e]

e <- ( [a] 'bcd' [e] / [a] / 'bcd' / [e] / [a]? 'bcd' / [e] )
     ( ([a] 'bcd' [e]) ([a] / 'bcd' / [e]) ([a]? 'bcd' / [e])   )
     ( ([a] 'bcd' [e])? ([a] / 'bcd' / [e]) ([a]? 'bcd' / [e])  )


e <-- ( [a] 'bcd' [e] / [a] / 'bcd' / [e] / [a] 'bcd' / 'bcd' / [e] )
e <-- ( [a] 'bcd' [e] / [a] / 'bcd' / [e] )
e <-- ( [a] ('bcd' [e] / succ) / 'bcd' / [e] )

d(t1) = [a]
d(t2) = 'bcd'
d(t3) = [e]

d(e1) = d(t1) = [a]
d(e2) = d(t1)/d(t2)/d(t3) = [a]/'bcd'/[e]
d(e3) = d(t1)/d(t2)/d(t3) = [a]/'bcd'/[e]

d(f1) = d(e1)/


!!!***********     e1? rest == e1 rest / rest   !!  Much better than (e1 / succ) rest
              (it seems) because it gives us a static determinant

e1 e2 e3? e4 e5 == e1 e2 (e3 e4 e5 / e4 e5)

e1 e2 expr? expr e4 == e1 e2 (expr expr e4 / expr e4) == e1 e2 expr (expr e4 / e4)
(also == )  e1 e2 expr expr? e4


expr?      ---> expr / succ      <--- only if it's the last term in an ord
expr? rest ---> expr rest / rest <--- anywhere else


e1/e2?/e3  --> already not allowed-  e3 never succeeds


*******  Worth it to do the same with star expressions?

e1 e2* e3 == e1 (e2 e2* e3 / e3)
e1 e2* e3 == e1 (&e2a e2* e3 / e3)


******
Predicates - can reduce to 'QUALIFIER' as long as every possibility is a static
terminal or has variable length less than 5 bytes...

!([a]/[b]/[c])         == Q([^abc])
!([a] [b] [c] [d] [e]) == Q(^'abcde')
!([a] [b]? [c] [d])    == Q(^


e <- !'abcde' 'abcd'

e <-- 'abcd' ![e]

case ... of
  <<_:Idx/bytes, 97,98,99,100,C, _/bytes>> when C =/= 101 -> ...
  ...
end
# very weak form of backtracking if it fails (will look up those bytes again).
# Possibly acceptable.

BUT

e <- !'abcde' 'abcd' / 'abcdefg'

REORDERER

e <-- 'abcdefg' / 'abcd'
e <=- 'abcd' ('efg' / succ)

grammar    <- rule* eof
rule       <- symbol LEFTARROW expression
expression <- (symbol !LEFTARROW)*
symbol     <- [a-z]
LEFTARROW  <- '<-'
---
grammar <- ([a-z]'<-' ([a-z]!'<-')*)*  eof

e <-  (a b*)*
e <-- a b* e / succ
e <-- a b b* e / a e / succ

e <-- a (b b* e / e) / succ
e <-- (a b b* / a)*

grammar <- ([a-z]'<-' [a-z]!'<-' ([a-z]!'<-')* / [a-z]'<-')* eof
grammar <--([a-z]'<-' ([a-z]!'<-' ([a-z]!'<-')* / [a-z]'<-'))* eof
                      ^                         ^          ^
grammar <--([a-z]'<-' ([a-z]'<-' / [a-z] ([a-z]!'<-')*)


e <-  (ab (a!b)*)*
e <-- (ab a!b (a!b)* / ab)*
e <-- (ab (a!b (a!b)* / succ))*
e <-- (ab (a!b (a!b)* / (ab (a!b (a!b)* / succ))))*
e <-- (ab (a!b (a!b)* / ab (a!b (a!b)* / succ)))*
e <-- (ab (  a!b (a!b)*
           / ab (a!b (a!b)* / succ)))*

e <=- (ab ( ab (a!b (a!b)* / succ) / a (a!b)*))*
grr


e <- (a b (a !b)*)*
(OR) e <-  stuff:(start:ab body:(a!b)*)*

e <-- ab e2 e / succ
e2<-- a!b e2 / succ

e <-- ab e2 e / succ
e2<-- a!b e2 / e     # Pull in tail from context
                     # don't need / succ because e always succeeds
e <-- ab e2 e / succ
e2<-- a!b e2 / (ab e2 e / succ)

# e2 now has full e, so e2 e is now redundant
e <-- ab e2 / succ
e2<-- a!b e2 / (ab e2 / succ)

e <-- ab e2 / succ
e2<-- a!b e2 / ab e2 / succ  # next is reorder first to terms

e <-- ab e2 / succ
e2<-- ab e2 / a e2 / succ
(OR) e2 <-- start:ab e2 / body:a e2 / succ

e <-- ab e2 / succ
e2<-- a (b e2 / e2) / succ
(OR) e2 <-- start:body:a (b {start} e2 / {body} e2) / succ

abaaaabaaabab
^    ^   ^ ^
'ab' : e[1,1] match, call e2 (collapse as start)
'a'  : e2[1,1] match, call e2[1,2]  (collapse as body)
'a'  : e2[1,2] -> e2[1,1], match, call e2[1,2]  (collapse former as body)
'a'  : e2[1,2] -> e2[1,1], match, call e2[1,2]  (collapse former as body)
'a'  : e2[1,2] -> e2[1,1], match, call e2[1,2]  (collapse former as body)
'b'  : e2[1,2,1] match, (collapse as start), call e2
...

SO:
e <- (a b (a !b)*)*

e <=- a b f / succ
f <=- a (b f / f) / succ

******
Hypothesis: predicates --> qualifier, reorder, or dead-code simplification (only)

Tricky:



******
New form: {tag} = collapse accumulator into specified tag
          {tag*} = collapse accumulator and add to tag's accumulator
	  {/transformer/} = execute transformation (but only if it is used
	    later on in another one)
(internal form, that is- not for use in the wild)
tag* -> for star and plus expressions or when multiple things tagged manually (?)

Or maybe:
 on collapse:  already one in there?  add another- now it's a list (or maybe
               always treat it as a list but then singularize it @ transform time)
 on transform: clear out all data that's used in the transform
               (unless it's referenced higher up?)

e <- tag1:e2 -> trsf1
e <-- tag1:e2 {tag1} {/trsf1/}

******
I'm thinking that auto-transforms for building an AST might be feasable after
all- especially if the children ones aren't executed unless they're used...

e <- a b         #(implied) -> {e,Pos,$_}
a <- 'abc'       #(implied) -> {a,Pos,$_}
b <- 'bcd'       #(implied) -> {b,Pos,$_}
input: 'abcbcd'
{e, {1,1}, {{a, {1,1}, 'abc'}, {b, {1,1}, 'bcd'}}}

BUT -
e <- a b -> {here_you_go, $1}
a <- 'abc'       #(implied) -> {a,Pos,$_}
b <- 'bcd'       #(implied) drop
input: 'abcbcd'
{here_you_go, {a, {1,1}, 'abc'}}

e <- A b         #(implied) -> {e,Pos,$_}
A <- 'abc'       #(implied) drop because it's a token
b <- 'bcd'       #(implied) -> {b,Pos,$_}
input: 'abcbcd'
{e, {1,1}, {b,{1,4},'bcd'}}

******
Thought: $_ as tuple but %_ as list? (or something)

****** NOTE ON STAR REDUCTION IN PLACE
e <-  something* rest
e <-- something e / rest
(including the case when "rest" is 'succ')

******
to prove: lookahead on terminal does not affect constant space / linear time complexity

******
NOTE: Possibly simplifies things (for users' understanding) if predicates are
completely invisible to transformation expressions. (problem might be when
they're counting the terms...)


