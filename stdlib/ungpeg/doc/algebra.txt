=== Reduced Form ===
 * Everything inlined except for recursive calls, entry-points, and accumulators
 * All prefix (predicate) attributes and suffix attributes reduced (see below)
 * No '+' accumulators- only '*' accumulators
 * No 'succ' expressions except as implied by ? on a non-succ expression.
   (That is, any 'succ' expressions in a seq or by itself can be safely
   removed).

= Ordered Priority Sequence (ord) =
 * Contains no ords (sucked inline)  # TODO: what attributes on an inner ord would overrule this?
 [strike?] * Contains no opts (all changed to inline term/succ) # TODO: ditto
 * Contains nothing after any 'star' term (which will always succeed)
 * Contains no 'succ' children
   * Contains nothing after 'succ' (removed w/ warning)
   * Tail succ rewritten as expr?
 * Contains no 'opt' children
   * opt child rewritten as child / succ
   * succ removed as per rule above
 * Contains at least two terms (if succ internal-error, if 1 child, replaces parent)
 * Contains no duplicate or equivalent terms (leftmost is kept)
 * Contains no terms to the right of e1 that has e1 as a prefix.
 * Tags allowed on any/all children and on whole
 * Transforms allowed on any/all children and on whole
 * All inner terms reduced

= Predicated Ordered Priority Sequence (!/& ord) =


= Sequence (seq) =
 * Any andp predicates preceding an ord 


== Normalized Attributes ==
 (One may recursively apply the rule combinations from innermost to outermost,
 stopping when all are processed or when an error is encountered.)
 (Does * terminate when nothing is consumed or just on failure?)Îµ
 ? * + & ! any eof succ fail
 Rule 1:  (e1?)? --> e1?
 Rule 2:  (e1?)* --> ERROR - degenerate loop at first character where e1 fails (intended?: e1*)
                           - not allowed in formal PEG
 Rule 3:  (e1*)? --> e1*
 Rule 4:  (e1?)+ --> ERROR - degenerate loop at first character where e1 fails (intended?: e1+)
                           - not allowed in formal PEG
 Rule 5:  (e1+)? --> e1*
 Rule 6:  &(e1?) --> succ - always succeeds without consuming input
 Rule 7:  (&e1)? --> succ - always succeeds without consuming input
 Rule 8:  !(eq?) --> fail - always fails without consuming input
 Rule 9:  (!eq)? --> succ - always succeeds without consuming input
 Rule 10: any?   --> (no change - always succeeds, consumes anything but eof)
 Rule 11: eof?   --> succ (same as rule 8)
 Rule 12: succ?  --> succ
 Rule 13: fail?  --> succ

 Rule 14: (e1*)* --> e1*
 Rule 15: (e1*)+ --> fail - e1* never leaves anything for + to consume
 Rule 16: (e1+)* --> e1*
 Rule 17: &(e1*) --> succ
 Rule 18: (&e1)* --> ERROR - degenerate loop
                           - not allowed in formal PEG
 Rule 19: !(e1*) --> fail
 Rule 20: (!e1)* --> ERROR - degenerate loop when e1 fails
                           - not allowed in formal PEG
 Rule 21: any*   --> (no change - terminates at eof)
 Rule 22: eof*   --> ERROR - degenerate loop ((!any)*)
                           - not allowed in formal PEG
 Rule 23: succ*  --> ERROR - degenerate loop
                           - not allowed in formal PEG
 Rule 24: fail*  --> ERROR - degenerate loop
                           - not allowed in formal PEG
 
 Rule 24: 
 -  * ->+ --> warning - child ate everything
 -  *<- + --> *
 -  * ->! --> warning - always fails
 -  *<- ! --> warning - fail in child causes grammar to degenerate
 -  * ->& --> no-op expression - always succeeds
 -  *<- & --> warning - success in child causes grammar to degenerate
 -  any*  --> (no change)
 -  succ*  --> error - Grammar will degenerate
 -  eof*  --> warning - eof causes grammar to degenerate ((!any)*)

 TODO: plusses and nots
 16- + ->! --> 

== Detect other degenerate loops ==
(From peg-popI04-2)
o = [0 -> success, nothing consumed,
     1 -> success, something consumed,
     f -> failure, nothing consumed,
     s -> 0 or 1]

1.  succ          --> 0
2.  any/char/lit  --> 1
3.  any/char/lit  --> f
4.  call          --> whatever its expression reduces to
5.  e1 e2 --> 0   if  e1-->0 and e2-->0
    e1 e2 --> 1   if  e1-->1 and e2-->s
    e1 e2 --> 1   if  e1-->s and e2-->1
6.  e1 e2 --> f   if  e1-->f
7.  e1 e2 --> f   if  e1-->s and e2-->f
8.  e1/e2 --> s   if  e1-->s
9.  e1/e2 --> o   if  e1-->f and e2-->o
10. e*    --> 1   if  e -->1
11. e*    --> 0   if  e -->f
12. !e    --> f   if  e -->s
13. !e    --> 0   if  e -->f
--------
14. e1/e2*  --> s
15. e1/e2?  --> s
16. e1/succ --> s
