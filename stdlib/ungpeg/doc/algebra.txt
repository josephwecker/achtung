=== Reduced Form ===
 * Everything inlined except for recursive calls, entry-points, and accumulators
 * All prefix (predicate) attributes and suffix attributes reduced (see below)
 * No '+' accumulators- only '*' accumulators
 * No 'succ' expressions except as implied by ? on a non-succ expression.
   (That is, any 'succ' expressions in a seq or by itself can be safely
   removed).

= Ordered Priority Sequence (ord) =
 * Contains no ords (sucked inline)  # TODO: what attributes on an inner ord would overrule this?
 [strike?] * Contains no opts (all changed to inline term/succ) # TODO: ditto
 * Contains nothing after any 'star' term (which will always succeed)
 * Contains no 'succ' children
   * Contains nothing after 'succ' (removed w/ warning)
   * Tail succ rewritten as expr?
 * Contains no 'opt' children
   * opt child rewritten as child / succ
   * succ removed as per rule above
 * Contains at least two terms (if succ internal-error, if 1 child, replaces parent)
 * Contains no duplicate or equivalent terms (leftmost is kept)
 * Contains no terms to the right of e1 that has e1 as a prefix.
 * Tags allowed on any/all children and on whole
 * Transforms allowed on any/all children and on whole
 * All inner terms reduced

= Predicated Ordered Priority Sequence (!/& ord) =


= Sequence (seq) =
 * Any andp predicates preceding an ord 


== Normalized Attributes ==
 (One may recursively apply the rule combinations from innermost to outermost,
 stopping when all are processed or when an error is encountered.)
 (Does * terminate when nothing is consumed or just on failure?)
 ? * + & ! any eof succ fail
 AttRule 1:  (e1?)? --> e1?
 AttRule 2:  (e1?)* --> ERROR - degenerate loop at first character where e1 fails (intended?: e1*)
 AttRule 3:  (e1*)? --> e1*
 AttRule 4:  (e1?)+ --> ERROR - degenerate loop at first character where e1 fails (intended?: e1+)
 AttRule 5:  (e1+)? --> e1*
 AttRule 6:  &(e1?) --> succ
 AttRule 7:  (&e1)? --> succ
 AttRule 8:  !(e1?) --> fail
 AttRule 9:  (!e1)? --> succ
 AttRule 10: any?   --> (no change - always succeeds, consumes anything but eof)
 AttRule 11: eof?   --> succ
 AttRule 12: succ?  --> succ
 AttRule 13: fail?  --> succ

 AttRule 14: (e1*)* --> e1*
 AttRule 15: (e1*)+ --> fail - e1* never leaves anything for + to consume
 AttRule 16: (e1+)* --> e1*
 AttRule 17: &(e1*) --> succ
 AttRule 18: (&e1)* --> ERROR - degenerate loop
 AttRule 19: !(e1*) --> fail
 AttRule 20: (!e1)* --> ERROR - degenerate loop when e1 fails
 AttRule 21: any*   --> (no change - terminates at eof)
 AttRule 22: eof*   --> ERROR - degenerate loop ((!any)*)
 AttRule 23: succ*  --> ERROR - degenerate loop
 AttRule 24: fail*  --> fail

 AttRule 25: (e1+)+ --> fail - never anything for the second to consume
 AttRule 26: &(e1+) --> (no change - valid)
 AttRule 27: (&e1)+ --> ERROR - degenerate loop if e1 succeeds
 AttRule 28: !(e1+) --> (no change - valid)
 AttRule 29: (!e1)+ --> ERROR - degenerate loop if e1 fails
 AttRule 30: any+   --> (no change - at least one before eof)
 AttRule 31: eof+   --> ERROR - degenerate loop
 AttRule 32: succ+  --> ERROR - degenerate loop
 AttRule 33: fail+  --> fail

 AttRule 34: &(&e1) --> &e1
 AttRule 35: !(&e1) --> !e1
 AttRule 36: &(!e1) --> !e1
 AttRule 37: &any   --> (no change)
 AttRule 38: &eof   --> (no change)
 AttRule 39: &succ  --> succ
 AttRule 40: &fail  --> fail

 AttRule 41: !(!e1) --> &e1
 AttRule 42: !any   --> eof
 AttRule 43: !eof   --> any
 AttRule 44: !succ  --> fail
 AttRule 45: !fail  --> succ

== Detect other degenerate loops ==
(From peg-popI04-2)
o = [0 -> success, nothing consumed,
     1 -> success, something consumed,
     f -> failure, nothing consumed,
     s -> 0 or 1]

1.  succ          --> 0
2.  any/char/lit  --> 1
3.  any/char/lit  --> f
4.  call          --> whatever its expression reduces to
5.  e1 e2 --> 0   if  e1-->0 and e2-->0
    e1 e2 --> 1   if  e1-->1 and e2-->s
    e1 e2 --> 1   if  e1-->s and e2-->1
6.  e1 e2 --> f   if  e1-->f
7.  e1 e2 --> f   if  e1-->s and e2-->f
8.  e1/e2 --> s   if  e1-->s
9.  e1/e2 --> o   if  e1-->f and e2-->o
10. e*    --> 1   if  e -->1
11. e*    --> 0   if  e -->f
12. !e    --> f   if  e -->s
13. !e    --> 0   if  e -->f
--------
14. e1/e2*  --> s
15. e1/e2?  --> s
16. e1/succ --> s
