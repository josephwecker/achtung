# One of these is started for every connection - basically handles state and
# communications with that single client.

@@extends(gen_server_basic)

<send|Dat, State|
  S = State.sock
  # An uncompressed binary wraps the real term so that we have the full size on
  # the client side without having to do zlib stuff.
  Encoded = term_to_binary(term_to_binary(Dat, [compressed, (minor_version, 1)]))
  @S.send(Encoded)

<init|[Server, Sock, Opts]|
  State =
    sock:   Sock,
    opts:   Opts,
    server: Server,
    acc:    <[ ]>
  (ok, State)

<handle_info|set,                 State|: (noreply, State)
<handle_info|shutdown,            State|: (stop, normal, State)
<handle_info|(tcp_closed, _),     State|: (stop, normal, State)
<handle_info|(tcp, _RSock, Data), State|
  Acc = State.acc
  #NewAcc = process_data(Data, State.opts.recipient, Acc)
  NewAcc = process_data(Data, none, Acc)
  (noreply, State.acc := NewAcc)

<handle_info|Outbound, State|
  send(Outbound, State)
  (noreply, State)

<terminate|_Reason, State|
  Server = State.server
  Server.rm_persistent(self())
  S = State.sock
  @S.close()

process_data|New, _, Acc|:
  io.format("Got data: ~p", [New])
  [Acc, New]  # which is to say, nyi

#process_data|_Server, Buff, [] |: binary_to_term(Buff, [safe])
#process_data|Server,  Buff, New|
