@@extends(gen_server_basic)

error|Txt, Dat|: error_logger.error_msg(Txt, Dat)
warn |Txt, Dat|: error_logger.warning_msg(Txt, Dat)
info |Txt, Dat|: error_logger.info_msg(Txt, Dat)

add_persistent|Server, Pid|: gen_server.cast(Server, (add_p, Pid))
rm_persistent |Server, Pid|: gen_server.cast(Server, (rm_p, Pid))

<init|Opts|
  switch socket_listen(Opts)
    case (ok, Listener)
      AcceptorPid = start_acceptor(Listener, Opts)
      State = {opts:        Opts,
               listener:    socket.new(Listener),
               acceptor:    AcceptorPid,
               persistents: []}
      (ok, State)
    case (error, Err)
      error("Couldn't seem to listen: ~p", [Err])
      (stop, Err)
    case ('EXIT', Reason)
      error("Bad error while listening: ~p", [Reason])
      (stop, Reason)

<handle_cast|stop,             State|: (stop, normal, State)
<handle_cast|(add_p, Pid),     State|
  Pers = [Pid : State.persistents]
  (noreply, State.persistents := Pers)

<handle_cast|(rm_p, Pid),      State|
  (noreply, State.persistents := lists.delete(Pid, State.persistents))

<handle_cast|(multicast, Msg), State|
  send_to_pids(State.persistents, Msg)
  (noreply, State)

<handle_cast|Msg,              State|
  warn("Received unknown message ~p", [Msg])
  (noreply, State)

<handle_info|('EXIT', _Pid, (error, ((accept_failed, (shutdown,_))))), State|
  # Shutdown in progress.  Ignore.
  (noreply, State)
<handle_info|('EXIT', _Pid, Reason), State|
  error("Acceptor has died with reason: \"~p\" - Reinitializing", [Reason])
  AcceptorPid = start_acceptor(State.listener, State.opts)
  (noreply, State.acceptor := AcceptorPid)
<handle_info|Info, State|
  warn("Received unknown info in ~p: ~p", [$module, Info])
  (noreply, State)

<terminate|_Reason, State|
  info("Shutting down socket server ~p and any connections.", [self()])
  L = State.listener
  L.close()
  exit(State.acceptor, kill)
  send_to_pids(State.persistents, shutdown)
  terminated

socket_listen|Opts|
  SockOpts = [binary,
              (nodelay,     struct.getdef(Opts, nodelay,     true)),
              (reuseaddr,   struct.getdef(Opts, reuseaddr,   true)),
              (packet,      struct.getdef(Opts, packet,      raw)),
              (packet_size, struct.getdef(Opts, packet_size, 1024))]
  Port = struct.getdef(Opts, port, 4113)
  gen_tcp.listen(Port, SockOpts)

start_acceptor|Listener, Opts|
  spawn_link($module, acceptor_loop, [self(), Listener, Opts])

<acceptor_loop|Server, Listener, Opts|
  switch gen_tcp.accept(Listener)
    case (ok, Sock)
      spawn_handler(Server, socket.new(Sock), Opts)
      acceptor_loop(Server, Listener, Opts)
    case (error, Error)
      error("Accept failed with error: ~p", [Error])
      acceptor_loop(Server, Listener, Opts)
    case ('EXIT', Error)
      error("Accept exited with error: ~p", [Error])
      exit( (error, (accept_failed, Error)) )

spawn_handler|Server, Sock, Opts|
  S = @Sock.raw_socket()
  HandoffFun = fn()
    receive set
      F = Opts.worker_loop
      F(Sock, Opts)
      rm_persistent(Server, self())
    after 60000
      error("Timeout waiting for set in controller. Closing.", [])
      @Sock.close()
  Pid = spawn(HandoffFun)
  switch gen_tcp.controlling_process(S, Pid)
    case ok
      Pid ! set
      add_persistent(Server, Pid)
    case (error, Err)
      error("Couldn't set the controlling process. Closing. ~p", [Err])
      @Sock.close()
    case Other
      error("Got back ~p", [Other])
      @Sock.close()

send_to_pids|[],  _Msg|: ok
send_to_pids|Pids, Msg|
  Send = fn(P){ try {P ! Msg} catch _ {nop}}
  [Send(P) for P in Pids]
  ok
