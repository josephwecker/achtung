grammar    <- _S rule+ EOF  `?p2`;
%rule       <- rule_name LEFTARROW expression transforms? `{?p1,?p4,?p3}`;
rule       <- rule_name LEFTARROW expression `{?p1,[],[],?p3}`;
rule_name  <- entry_point? symbol &LEFTARROW `c_rulename(?p1,?p2)`;
%transforms <- RIGHTARROW simple_erl_term `?p3`;
expression <- ordered / sequence / primary ~;
ordered    <- alternative (SLASH alternative)* `[?p1|?i(2,2)]`;
alternative <- 


%simple_erl_term <- list / tuple / funcall / atom ~;
%list <- LEFTBRACKET 




`
-define(X, []). % Consume but ignore
-define(N, Node).
-define(I, Index).
-define(inspect, ?inspect(?N)).
-define(inspect(N), begin io:format("~n====== inspect =======~n~p~n"
        "======================~n", [N]), N end).

-define(p1, ?p1(?N)).
-define(p2, ?p2(?N)).
-define(p3, ?p3(?N)).
-define(p4, ?p4(?N)).
-define(p5, ?p5(?N)).
-define(p6, ?p6(?N)).
-define(flat, ?flat(?N)).
-define(rev, ?rev(?N)).
-define(p1(L), lnth(1,L)).
-define(p2(L), lnth(2,L)).
-define(p3(L), lnth(3,L)).
-define(p4(L), lnth(4,L)).
-define(p5(L), lnth(5,L)).
-define(p6(L), lnth(6,L)).
-define(ip1, ?ip1(?N)).
-define(ip2, ?ip2(?N)).
-define(ip3, ?ip3(?N)).
-define(ip4, ?ip4(?N)).
-define(ip1(L), [?p1(IL)||IL<-L]).
-define(ip2(L), [?p2(IL)||IL<-L]).
-define(ip3(L), [?p3(IL)||IL<-L]).
-define(ip4(L), [?p4(IL)||IL<-L]).

% ?i(3,4) == ?ip4(?p3)
-define(i(OPos,IPos), [lnth(IPos, IL)||IL<-lnth(OPos,?N)]).
-define(flat(L), lists:flatten(L)).
-define(rev(L), lists:reverse(L)).
-define(all(Key,L), proplists:get_all_values(Key,?flat(L))).
-define(listify, ?listify(?N)). % Ensure it's a list
-define(listify(V), case V of [_|_]->V;_->[V] end).
-define(app(L,V),case V of []->L;_->lists:append(L,[V]) end).% Append V onto L sometimes
-define(unlist1, ?unlist1(?N)).
-define(unlist1(N), case N of [O]->O;_->N end).


c_rulename(S) -> c_rulename([],S).
c_rulename([], S) -> list_to_atom(?flat([$%,S]));
c_rulename("*",S) -> {'ENTRY',list_to_atom(?flat([$%,S]))}.



% vim: set noai filetype=erlang textwidth=100:
`

